{
id: "frogatto_playable",
prototype: ["player_controlled_platformer_character"],
hitpoints: 4,
mass: 5,
friction: 2000,
solid_area: [9,8,23,30],
traction_in_water: 1000,
affected_by_currents: true,
feet_width: 5,
zorder: "@include data/zorder.cfg:player",

editor_info: {
	help: "This sets where Frogatto starts on a given level, if the game starts on that level or if the player is teleported to that level without a specific object as a destination. Instances placed in-level will be ignored if there is already a playable character the player is playing.",
	category: "player",
},

//these spritesheets get switched for fat frogatto, so we can't compile them.
no_compile_image: "characters/frogatto-spritesheet1.png,characters/frogatto-spritesheet3.png,characters/frogatto-spritesheet4.png,characters/frogatto-spritesheet5.png",
load_variations: "fat",

properties: {
#-------------------------- attack/damage handlers --------------------------#
	flinch_threshold: 0, //Used to trigger when we do that little 'jump' when we get hurt. Since we always want to do it, we've got the variable set to 0. It defaults to 3, otherwise.
	character_specific_damage_response: "def(string damage_type, int amount) -> commands if(amount > 0, if(is_currently_fat, shoot_spit_attack, animation('hurt')) )",

	play_object_specific_pain_vocalization: "def(string damage_type, damage_amount) -> commands sound('TakeDamage.wav')",

#-------------------------- general handlers --------------------------#
	zombie_object_cleanup: "commands :: [remove_object(_tongue_tip), set(_tongue_tip, null)]",

	is_player_body_part: "true",

	_cycles_since_last_touching_ground: { type: "int", default: 0 },
	postjump_grace_period: "10",

	can_jump: "def() -> bool
	  	bool(is_standing and (animation not in ['interact', 'fall', 'jump', 'start_jump']) or 
			//after frogatto starts falling off a ledge, give the player a little grace in allowing them to still initiate a jump.
	     animation = 'fall' and _cycles_since_last_touching_ground < postjump_grace_period)",
	
	bounce_on: "def(obj standard_values object_being_stood_on) -> commands [
		set(velocity_y,
			-max(object_being_stood_on.spring_amount,
				((velocity_y * object_being_stood_on.springiness)/100 * (100 - abs(bounce_angle)))/100
			)
		),
		add(velocity_x, 
			((velocity_y * object_being_stood_on.springiness)/100*bounce_angle)/100
		),
		fire_event(object_being_stood_on, 'bounced_on'),
		set(_last_bounced, cycle),
		set(_bounced_on_chain, new_bounced_on_chain),
		if(_bounced_on_chain > 8, achievement('jackalope')),
		] where bounce_angle = (object_being_stood_on.bounce_roundness * (mid_x - object_being_stood_on.mid_x))/(max(1, object_being_stood_on.w)),
				new_bounced_on_chain = if(object_being_stood_on['team'] != 'evil', 0, _bounced_on_chain + 1)",
	
	register_annoyed_npc: "def(string name) -> commands debug('Recorded ' + name + ' as annoyed.')",
	
	do_post_victory_transport: "def(string target_level, string target_obj) -> commands execute(me,[
									standard_victory_music,
									title('Victory!',200),
									do_cinematic_float(
									[
									def() schedule(1, sinusoidal_transition({period:90, _init_theta:0.0, _length_theta:1.0, addend:2, coefficient:1, obj:level, aspect:'zoom'})),
									def() schedule(89, set(level.player.control_lock, null)),
									def() schedule(90, if(target_level and target_obj, teleport(target_level, target_obj, 'iris'))),
									def() schedule(92, screen_flash([0,0,0,255], [0,0,0,0], 100)),
									def() schedule(92+100, screen_flash([0,0,0,255], [0,0,0,-3], 85)),
									]
									)
								]) asserting target_obj != '' and target_level != ''",
	do_post_victory_without_transport: "def([function() -> commands] post_landing_todos) -> commands execute(me,[
					standard_victory_music,
					title('Victory!',200),
					do_cinematic_float(
					[def() schedule(119, set(level.player.control_lock, null)),
					def() schedule(60, sinusoidal_transition({period:100, _init_theta:1.0, _length_theta:1.0, addend:1, coefficient:1, obj:level, aspect:'zoom'})),
					def() schedule(160, set(level.zoom, 1.0))] + post_landing_todos
					)
				])",
	do_cinematic_float: "def(null|[function() -> commands] additional_landing_todos) -> commands [
							set(level.player.rotate, 0),
							set(level.player.control_lock, []),
							set(level.player.velocity_x,0),
							set(level.player.accel_x,0),
							animation('floating_spin'),
							do_upon_landing( [def() animation('emote_victory')] ),
							if(additional_landing_todos != null, map(additional_landing_todos, do_upon_landing( [value] ))),
							sinusoidal_transition({period:period/4, _init_theta:0.0, _length_theta:1.0, addend:1, coefficient:1, obj:level, aspect:'zoom'}),
							sinusoidal_transition({period:period, _init_theta:1.0, _length_theta:1.0, addend:0, coefficient:-200, obj:level.player, aspect:'velocity_y'}),
							schedule(1*(period/4),animation('floating_spin_fast')),
							schedule(2*(period/4),animation('floating_spin_faster')),
							schedule(period - period/8,animation('floating_spin')),
						] where period = 400",
	
	do_upon_landing: "def([function() -> commands] todo) -> commands add(_todo_upon_landing, todo)",
	fullfill_todo_upon_landing: "if(_todo_upon_landing != null, [map(_todo_upon_landing,value()),set(_todo_upon_landing, null)])",
	
	_todo_upon_landing: {type: "[function() -> commands]|null", default: null}, 
	
	
	/*tracking key presses:  we can accomplish mouseup, mousedown, and mouse-held by doing the following:
	 By setting the cycle on which a key is pressed, we limit ourselves to a set of keys that need to be re-checked on later frames to see if they're still held down.  We don't need to register key-tracking up-front, as having an access of ctrl_keyboard in on_process will make this implicit (though any gap of more than one cycle in on_process tracking will break continuity of key-holds).
	 
	 On the first frame, we set the current cycle a key has been pressed at.  We leave this alone if the key continues being pressed (which allows us to know how long it's been pressed), or if a key is released, we null this out. */
	
	_key_store: { type: "{string -> int|null}", default: {} },
	track_key: "def(string key_name) ->commands if(key_name in ctrl_keys, if(not key_name in _key_store, add(_key_store, {(key_name) -> cycle})), set(_key_store[key_name], null))",
	ctrl_keyboard: "def(string key_name) ->int|null if(key_name in _key_store, (cycle - (int <- _key_store[key_name])), null )",

	spawn_on_ref: "def(string name, decimal x, decimal y, int facing) -> commands [
		set(obj.parent, self.standing_on),
		add_object(obj),
		] where obj = object(name, x, y, facing)",
        	
#-------------------------- cheat codes --------------------------#
	//in the spirit of early cheat codes, this is meant to make testing later levels more balanced against how powerful the player would normally be on such a level; it immediately empowers the player as though the player has purchased a bunch of late game upgrades.  This way we don't fall into making the levels easy enough to pass on a mere 2 hearts.
	//note that the way to enter this code is to type ctrl+d to bring up the debug prompt, type "hax", press return to execute the code, and then press escape to turn off the debug prompt.
	hax: "[
		map(range(size(ability_list_full)), schedule(value,fire_event('hax'))),
		set_item_amount('tongue_extension', 2),
		set_item_amount('greater_mana_talisman', 1),
		set_item_amount('lesser_mana_talisman', 1),
		add_item('acquirable_attractor', 1),
	]",
	hax_: "[
		set(max_hitpoints, 10), 
		set(hitpoints, 10),
		set(mana, 5000), 
		map(ability_list_full, add_ability(value)),
		]",	
	choppa: "set(_jump_cheat,true)",
	smite: "map(filter(level.chars, value is obj hittable), if(value.team = 'evil', set(value.hitpoints, 0)))",
	supes: "[hax,choppa,set(invincible,-1)]",


#-------------------------- inventory handlers --------------------------#
	
		#-- Passive Items --#
	item_list_full: "['lesser_mana_talisman','greater_mana_talisman','tongue_extension']",
	//future ones we'll be adding "['mana_container','medium_mana_talisman','heart_container','heart_container_piece']",


		#-- Abilities --#
	ability_list_full: "['tongue','firebreath','energyshot','homingshot','acidbreath']",
	add_ability: "def(string name) -> commands
		if((not name in ability_list) asserting name in ability_list_full, 
			set(ability_list, sort(ability_list + [name], index(ability_list_full, a) < index(ability_list_full, b))))",
	current_ability_name: "ability_list[current_ability]",

#-------------------------- general animation handlers --------------------------#
	uninterruptible_animations: "['turn', 'crouch', 'enter_crouch','interact'] + emote_animations + cinematic_animations + attack_animations",
	
	emote_animations: "['emote_victory', 'emote_angry', 'emote_nod', 'emote_talk', 'emote_raisedfinger', 'emote_impatient', 'emote_confused', 'emote_oh', 'emote_geez']",
	cinematic_animations: "['item_get_begin', 'item_get_hold', 'item_get_end']",
	interruptible_cinematic_animations: "['floating_spin', 'floating_spin_fast', 'floating_spin_faster']",
	attack_animations: "['jump_attack', 'energyshot', 'attack', 'walk_attack', 'firebreath_begin','firebreath_cycle','firebreath_end', 'spit']",
	jump_animations: "['start_jump','jump','fall']",


	maintain_locomotion: "commands :: set(accel_x, coeff * magnitude)
								where coeff = if(ctrl_left or ctrl_right, if(animation = 'turn', 0.3,1), 0), where magnitude = if(is_running, run_accel, walk_accel)",


#-------------------------- attack/ability handlers --------------------------#
	//NOTE: regarding channelled attacks, especially those which consume a low amount of mana per frame.
	// Problem:  if your only requirement to initiate the attack is the mana/frame cost, then you will "sputter" when your mana is low.  For example, if it takes 20 mana to fire a round, and it takes 10 frames to recharge that much (say, recharging 2 mana/frame), you'll go from firing a constant steam of one projectile/frame, to firing only one projectile every 10 frames 
	// Visually, this actually looks kinda cool on the fire attack, but it's problematic, because the high cooldown means that this sputtering version is as effective as the real thing even if you have no mana!
	// There are a few options to prevent this, we've gone with both 1 and 2 for now:
	// 1] when mana is exhausted, incur a "mana shock" timeout where all mana-based abilities are unuseable for a few moments.
	// 2] keep burning mana at the same rate, regardless of whether the powerup is being used, for the full cooldown duration of the ability.
	// 3] incur a startup cost to initiate the ability at all; if something costs 2 mana/frame, maybe charge 40 mana to start the ability up at all.
	// 4] rather than a startup cost, require the player to have at least > X mana to use the ability.  This differs from 2] in not actually consuming that startup cost, just requiring you to have it.
	attack: "def() -> commands 
		if('fat' in variations, tongue(), 
			if(underwater, shoot_bubble(),
				switch(ability_list[current_ability],
					'tongue', tongue(),
					'firebreath', mana_shock_guard(shoot_fire),
					'energyshot', mana_shock_guard(shoot_energy_shot),
					'homingshot', mana_shock_guard(shoot_homing_shot),
					'acidbreath', mana_shock_guard(shoot_acid)
				)
			) 
		)",
		
	spawn_tongue: "def(decimal angle) -> commands
			[if(animation in ['stand', 'leave_crouch', 'walk', 'run', 'enter_lookup', 'lookup','skid', 'land'], animation('attack')),
			if(animation in ['jump', 'fall', 'start_jump'], animation('jump_attack')),
			spawn('${self.type}.tongue_tip', if(facing > 0, x + 30, x), y + 46, {facing: facing, _tongue_angle:angle, _frog: me}, [set(_tongue_tip, child)])]",
	
	tongue: "def() -> commands
			if(ctrl_tongue_counter > 1 or (_tongue_tip != null), null,
				if('fat' in variations,
					if(not (animation in ['interact']), shoot_spit_attack ),
					[
						if(animation in ['stand', 'leave_crouch', 'walk', 'run', 'enter_lookup', 'lookup','skid', 'land', 'jump', 'start_jump', 'fall'],
							if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_up, spawn_tongue(-45),
								if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_down, spawn_tongue(45),
									if(ctrl_up, spawn_tongue(-90), if(ctrl_down, spawn_tongue(90), spawn_tongue(0))))))
					]
				)
			)",
	
	
#-------------------------- mana --------------------------#
	mana_base_regen_coefficient: "10*(0.5 + if(has_item('lesser_mana_talisman'), 0.3333, 0.0) + if(has_item('greater_mana_talisman'), 0.6667, 0.0))",
	
	//This is a pretty carefully-tuned non-linear function that makes low levels of mana give much faster regen, so that you're not stuck helpless on levels without base combat available.  The purpose then of mana isn't primarily about "running out", but about keeping high-consumption techniques harder to use.  Basically this makes the ability to use techniques scale with the amount of mana you have, which matters because the actual usefulness value in the game changes accordingly (being able to do a pea-shooter attack is priceless when you have almost no mana)
	mana_regen_per_frame: "mana_base_regen_coefficient*max(0.1,((max_mana-(mana/3))/decimal(max_mana))^8)",
	
	mana_costs: "{'firebreath' : 35, 'homingshot' : 1000, 'energyshot' : 200, 'acidbreath' : 650}",
	
	//mana_cooldown_time: how long mana keeps burning and the interval between which the ability can't deal damage
	mana_cooldown_time: "{'firebreath' : 10, 'homingshot' : 0, 'energyshot' : 0, 'acidbreath' : 0}", 
	
	//ability_charge_time: how long an ability needs to "charge up" before you can fire it again 
	ability_charge_time: "{'firebreath' : 0, 'homingshot' : 30, 'energyshot' : 5, 'acidbreath' : 60}",
	
	//check all the standard criterion for whether the ability can be used.
	ability_is_charged_up: "def(string ability_name) -> bool 
		(not mana_shock_active)
		and mana >= mana_costs[ability_name]
		and min(
			ability_charge_time[ability_name],
			cycle-started_using_ability_at_cycle[ability_name]
			) >= ability_charge_time[ability_name]",
	
	//check if we need to burn mana after having just used this ability
	ability_is_cooling_down: "def(string ability_name) -> bool 
		min(
			mana_cooldown_time[ability_name],
			cycle - started_using_ability_at_cycle[ability_name]
			) < mana_cooldown_time[ability_name]",
	
	//used for regular, active consumption - note that we DON'T subtract mana if we're cooling down, otherwise we'd double-dip
	use_mana_for_ability: "def(string ability_name) -> commands [
		if(not ability_is_cooling_down(ability_name),
			add(mana, -mana_costs[ability_name])),
		set(me.started_using_ability_at_cycle[ability_name], cycle)
		]",
	
	//used in the process loop to burn cooldown mana for any recently used powers
	use_mana_cooldowns: "def() -> commands map(ability_list_full, if(ability_is_cooling_down(value), add(me.mana, -mana_costs[value]) ))",
	
	
#-------------------------- attacks --------------------------#
	shoot_bubble: "def()  -> commands
		if(cycle%8=0,	[spawn('${self.type}.bubble_shot',midpoint_x+10*facing,midpoint_y,{facing: facing, _parent_obj: me}, [set(child.velocity_x,if((ctrl_up or ctrl_down) and (not(ctrl_left or ctrl_right)),1d100-50,400+1d100)*facing + me.velocity_x),set(child.velocity_y,1d100-50 + if(ctrl_up,-400-1d100,0) + if(ctrl_down,400+1d100,0) + me.velocity_y)]),sound('bubble-blow'+1d8+'.wav') ])",

	shoot_fire_active: "ctrl_tongue_counter > 1 and (not animation in ['enter_crouch', 'crouch']) and ability_is_charged_up('firebreath') and (animation in ['firebreath_begin','firebreath_cycle','firebreath_end'])",
	
	shoot_fire: "commands :: [if((not (shoot_fire_active)) and (not animation in ['enter_crouch', 'crouch']) and ability_is_charged_up('firebreath'), animation('firebreath_begin')), shoot_fire_internal()]",
	
	shoot_fire_internal: "def() -> commands if( ability_is_charged_up('firebreath') and
		animation in ['firebreath_begin','firebreath_cycle','firebreath_end'], [spawn('${self.type}.fire_shot',midpoint_x+1d10*facing,midpoint_y+4,facing, 
			[set(child.velocity_x,(1500+1d250)*facing),set(child.velocity_y,1d900-450)]), use_mana_for_ability('firebreath'), if(cycle >= (last_played_fire_sfx + 12) or last_played_fire_sfx = null, [sound('firebreath'+1d5+'.wav'),set(last_played_fire_sfx,cycle)])])",


	shoot_acid: "commands :: [if((not (shoot_acid_active)) and (not animation in ['enter_crouch', 'crouch']) and ability_is_charged_up('acidbreath'), animation('acidbreath_begin')), shoot_acid_internal()]",

	shoot_acid_active: "ctrl_tongue_counter > 1 and (not animation in ['enter_crouch', 'crouch']) and ability_is_charged_up('acidbreath') and (animation in ['acidbreath_begin','acidbreath_cycle','acidbreath_end'])",
			
	shoot_acid_internal: "def() -> commands if( ability_is_charged_up('acidbreath') and
		animation in ['acidbreath_begin','acidbreath_cycle','acidbreath_end'], [spawn('${self.type}.acid_shot',midpoint_x+1d10*facing,midpoint_y+4,{facing: facing, _parent_obj: me}, 
			[set(child.velocity_x,(500+1d150)*facing),set(child.velocity_y,1d400-250)]), use_mana_for_ability('acidbreath'), if(cycle >= (last_played_fire_sfx + 12) or last_played_fire_sfx = null, [sound('firebreath'+1d5+'.wav'),set(last_played_fire_sfx,cycle)])])",


	shoot_homing_shot: "commands ::
		if(ability_is_charged_up('homingshot') and (not animation in energyshot_anim_list), [schedule(1,animation(energyshot_anim)), homingshot_fire_projectile(energyshot_angle), energyshot_spawn_head(), use_mana_for_ability('homingshot')])",
	
	homingshot_fire_projectile: "def(decimal angle) -> commands spawn('${self.type}.homingshot', midpoint_x + 45*facing*cos(angle), midpoint_y + 40*sin(angle), facing, [set(child.velocity_x, velocity_x/4 + 2000 * cos(angle) * facing), set(child.velocity_y, velocity_y/4 + 2000 * sin(angle))])",

	
	shoot_energy_shot: "commands ::
		if(ability_is_charged_up('energyshot') and (not animation in energyshot_anim_list), [schedule(1,animation(energyshot_anim)) ,energyshot_fire_projectile(energyshot_angle), energyshot_spawn_head(), use_mana_for_ability('energyshot')])",
	
	energyshot_fire_projectile: "def(decimal angle) -> commands spawn('${self.type}.energyshot', midpoint_x + 45*facing*cos(angle), midpoint_y + 40*sin(angle), facing, [set(child.velocity_x, velocity_x/4 + 2000 * cos(angle) * facing), set(child.velocity_y, velocity_y/4 + 2000 * sin(angle))])",
	
	energyshot_angle: "if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_up, -45,
				if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_down, 45,
					if(ctrl_up, -90, if(ctrl_down, 90, 0))))",
	
	energyshot_spawn_head: "def() -> commands spawn('${self.type}.frogatto_head_energyshot',midpoint_x,midpoint_y-8,{facing: facing, _head_angle: energyshot_angle})",
	
	energyshot_anim: "switch(null, //If nothing is to be switched upon, then the function switches based on the first true key.
		me.animation in ['stand', 'leave_crouch', 'walk', 'enter_lookup', 'lookup','skid', 'land'], if(abs(slope_standing_on) < 20, 'energyshot', if(slope_standing_on*facing > 0, 'energyshot_down_slope', 'energyshot_up_slope')),
		me.animation in ['jump', 'fall'], 'energyshot_jump',
		'energyshot')",
	
	energyshot_anim_list: "['energyshot','energyshot_up','energyshot_down','energyshot_jump','energyshot_crouch','energyshot_swim_side','energyshot_swim_down','energyshot_swim_up']",

	super_fireball_fire_projectile: "commands :: spawn('${self.type}.super_fireball', mid_x + 45*facing, mid_y, facing, [set(child.velocity_x, velocity_x/4 + 800 * cos(angle) * facing), set(child.velocity_y, velocity_y/4 + 800 * sin(angle))]) where angle = 0",

	super_energyshot_fire_projectile: "commands :: spawn('${self.type}.super_energyshot', mid_x + 5*facing, mid_y, facing, [set(child.velocity_x, 300 * cos(angle) * facing), set(child.velocity_y, 300 * sin(angle))]) where angle = 0",

	super_homingshot_fire_projectile: "commands :: spawn('${self.type}.super_homingshot', mid_x, mid_y, facing)",

	super_acidshot_fire_projectile: "commands :: spawn('${self.type}.super_acidshot', mid_x, mid_y, facing)",

	shoot_spit_attack: "commands :: [if(not animation = 'spit', [animation('spit'), schedule(8, [spit_attack_fire_projectile,set(is_currently_fat, false),set(variations, [])]) ]),
								]",
	
	empty_stomach: "commands :: [set(is_currently_fat, false),set(variations, []), set(swallowed_object, null)]",
	
	spit_attack_fire_projectile: "commands :: 
			if(swallowed_object,
				[if(swallowed_object.type = 'padlock_key', standard_spit_attack,
					switch( ability_list[current_ability],
						'firebreath', [super_fireball_fire_projectile, set(swallowed_object, null), do_sound],
						'energyshot', [super_energyshot_fire_projectile, set(swallowed_object, null), do_sound],
						'homingshot', [super_homingshot_fire_projectile, set(swallowed_object, null), do_sound],
						'acidbreath', [super_acidshot_fire_projectile, set(swallowed_object, null), do_sound],
						'tongue', standard_spit_attack))
			
						where standard_spit_attack = [
							sound('frogatto-spit1.wav'),
				
							set(green, 255), set(blue, 255),
							add(gravity_shift, -swallowed_object.carry_gravity),
							set(swallowed_object.velocity_x, velocity_x + facing*(200 + 7*if(ctrl_up or ctrl_down, spit_power/2, spit_power*2))),
							set(swallowed_object.velocity_y, velocity_y - (600 + if(ctrl_up, if(ctrl_down, -200,200 + 7*spit_power), 0))),
			
							set(swallowed_object, null),
			
							//set the enemy to be in the thrown dimension, meaning it will only collide with the level. If it collides with another object, it should pass through that object in terms of solidity (any collision should actually be handled by body/attack areas, and most likely we expect it to die).
							set(swallowed_object.solid_dimensions_in, ['thrown']),
							set(swallowed_object.animation, 'thrown'),
			
							set(swallowed_object.midpoint_x, midpoint_x + velocity_x/10),
							set(swallowed_object.midpoint_y, midpoint_y - if(is_standing, 2, 22*sign(-velocity_y))),
							resolve_solid(swallowed_object, facing, 0, 50),
							resolve_solid(swallowed_object, -facing, 0, 50),
			
							add_object(swallowed_object),
							fire_event(swallowed_object, 'spat'),
							if(underwater, set(has_feet, false)),

							map(filter(level.active_chars, value is obj standing_npc), if(can_see(me,value), commands<- eval(value.consider_object, {me: value, obj: swallowed_object, level: level}))),
						],
				  set(current_ability, index(ability_list,'tongue'))]) where do_sound = sound('uber-belch'+1d5+'.wav')",

#-------------------------- item management --------------------------#
	has_item: "def(string item_name) -> bool items_carried[item_name] > 0",
	
	number_of_item: "def(string item_name) -> int if(has_item(item_name), items_carried[item_name], 0)",
	
	add_item: "def(string item_name, int count) -> commands
		set(items_carried, zip(items_carried, {(item_name) : count}, a+b))
		asserting item_name != '' | {message:'Attempting to get an item out of inventory, but the item type given is an empty string.', name:item_name, count:count}",
	
	set_item_amount: "def(string item_name, int count) -> commands
		add(items_carried, {(item_name) : count}) //This sets the amount, because lists when added to overwrite values if the key already exists.
		asserting item_name != '' | {message:'Attempting to set an item in inventory, but the item type given is an empty string.', name:item_name, count:count}",
	
	do_key_check: "if(swallowed_object is obj padlock_key, if( size(swallowed_object.valid_levels) > 0, if(not level.id in swallowed_object.valid_levels, 
						[set(me.variations, []), set(me.swallowed_object, null),transient_speech_dialog(250, level.player, [~I better put this key back where it came from.~]),
							empty_stomach]
					)))",
#-------------------------- movement commands --------------------------#
		
	should_be_standing: "bool <- self.animation in ['stand', 'run', 'walk', 'land', 'lookup', 'crouch', 'enter_crouch', 'leave_crouch', 'turn','turn_whilst_running', 'roll','skid']",
	
	set_facing: "def(int direction) -> commands
		if(self.facing != direction and (not (self.animation in ['interact', 'slide','turn','turn_whilst_running'])), [
			facing(direction),
			if(self.is_standing, animation('turn')),
			set(_last_turned, cycle)
		])",
	_last_turned: { type: "int", default: -10 },

		
	on_end_turn_whilst_running_anim: "[animation('run'), set(time_in_animation, 2*6)]",
	
	resume_standing_or_walking: "if(ctrl_left or ctrl_right, [if(ctrl_left, start_moving(-1)), if(ctrl_right, start_moving(1))], start_standing)",
		
	start_standing: "commands :: 
		if((abs(self.velocity_x)) > 750 and (not self.animation in ['walk']), [animation('skid'),set(accel_x,500)],
			if(not self.animation in ['stand'], animation('stand'))
		)",
	
	//sets rotation based on frogatto's relative velocity.  This tries to make frogatto tilt forward/backward if he's jumping with a lot of velocity behind him.  Has a factor which tries to dampen it markedly if the x_velocity is low, so if frogatto's jumping straight up and down, he doesn't wobble back and forth wildly.
	set_aerial_rotation: "def(decimal coefficient) -> commands set(rotate,coefficient*magnitude*angle/4.0) where angle = atan(decimal(velocity_y)/(velocity_x)) where magnitude = min(1.0,decimal(abs(velocity_x)*1.5)/sqrt(velocity_x^2 + velocity_y^2))",
	
	should_roll: "bool :: (cycle - last_landed_hard < 24)",
	should_continue_roll: "def(int dir) -> bool (animation = 'roll') and ((cycle - last_landed_hard < 12) or ((dir = 1 and ctrl_right) or (dir = -1 and ctrl_left)))",	
	
	start_moving:	//only for tracking movement keypresses, NOT for any actual gameplay logic
									"def(int dir) -> commands [set_facing(dir), 
										if(last_pressed(dir) and last_pressed(dir) > cycle - 15 or is_running = true, [
											process_movement_internal(-1, 'run'),
											set(is_running, true),
										]),
										
										if(dir = 1, [set(ctrl_right_counter, cycle),set(ctrl_left_counter, 0)]),
										if(dir = -1, [set(ctrl_left_counter, cycle),set(ctrl_right_counter, 0)])
	
									] where last_pressed = def(dir) if(dir = 1, ctrl_right_counter, ctrl_left_counter)",
	
	process_movement: "def(int direction) -> commands [if(should_roll, process_movement_internal(direction, 'roll'),
											if(is_running, process_movement_internal(direction, 'run'), process_movement_internal(direction, 'walk')))]",

	process_movement_internal: //gameplay logic and animation logic for movement
	"def(int dir, string anim) -> commands
			if(self.is_standing, [
				switch(anim,  //things that should happen every frame
					'walk', 	set(accel_x, walk_accel),
					'run', [set(accel_x, run_accel), [if(animation = 'walk', set(animation, 'run')), if(animation = 'turn_whilst_running' and time_in_animation >= 14, [set(animation,'run'),set(time_in_animation,12)])]],
					'roll', set(accel_x, roll_accel) ),
				if(animation in uninterruptible_animations, set(accel_x, 0)),
				if((not should_roll) and (animation = 'roll'), animation(anim)),
	
				//things that should only happen when the move begins
				if((not self.animation in ['stand_to_walk','walk', 'run', 'roll', 'start_jump', 'jump', 'fall', 'turn_whilst_running'] + uninterruptible_animations ), [
					switch(anim,
						'walk', animation('stand_to_walk'),
						'run', if(cycle - _last_turned < 10, animation('turn_whilst_running'), animation(anim)),
						animation(anim)),
                    if(anim = 'roll', if((cycle - last_landed_hard < 2), sound('frogatto-fall-roll.wav', 0.5))),
					if(anim = 'run', sound('runSoft.wav')),
				])
			],
			
			//Frogatto is in the air, so make him glide.
			if(not self.is_standing or self.animation in ['slide', 'swim_up', 'swim_down', 'swim_side'],
				add(self.velocity_x, jump_glide*dir))
		)",
	
	stop_moving: "commands :: if(not should_continue_roll(facing), [set(is_running, false), if((not (ctrl_left or ctrl_right)) and animation in ['stand_to_walk','walk', 'run', 'roll', 'turn_whilst_running'], start_standing)])",
	
	//Function to attempt to make Frogatto crouch; does checking to make
	//sure he's in a state that allows entering a crouch.
	crouch: "def() -> commands
		if((not self.animation in uninterruptible_animations ) and self.is_standing, 
			animation('enter_crouch'))",
	  		
	//Function to enter swimming frames.
	swim: "def(decimal dirx, decimal diry) -> commands
		if(dirx or diry, [
			if(self.animation != anim_wanted, animation(anim_wanted)),
			add(self.velocity_x, (swim_accel*dirx)/1000),
			add(self.velocity_y, (swim_accel*diry)/1000),
		]) where anim_wanted = if(abs(diry) > 500, if(diry < 0, 'swim_up', 'swim_down'), 'swim_side'),
		         swim_accel = 140",
		
	//function to decide if frogatto can slide down a wall
	can_slide: "bool <- bool(
		(not is_currently_fat)
		and point_solid(level, me, if(facing > 0, solid_rect.x2+1, solid_rect.x-1), (solid_rect.y + solid_rect.y2*2)/3)
		and (velocity_y < 300 and velocity_y > -1000 or ctrl_jump and pressed_jump_in_air) )",
		
		
#-------------------------- gui / hud --------------------------#
	
	gui_heart_display: {
		type: "obj heart_display", 
		init: "object('heart_display', 27+10, 27+52, {})", //27 is offset for some sort of interaction with the default animation, object positioning, etc.
		persistent: false,
	},
	gui_ability_display: {
		type: "obj ability_display", 
		init: "object('ability_display', 27+10, 27+10, {})",
		persistent: false,
	},
	gui_mana_display: {
		type: "obj mana_display", 
		init: "object('mana_display', 27+48, 27+32, {})",
		persistent: false,
	},
	gui_score_display: {
		type: "obj number_display", 
		init: "object('number_display', 27+48+8, 27+10+2, {field: 'score', prefix: ~score: ~})",
		persistent: false,
	},
	gui_highest_score_display: {
		type: "obj number_display", 
		init: "object('number_display', 27+48+80, 27+10+2, {field: 'high_score', prefix: ~best: ~})",
		persistent: false,
	},
	gui_coins_display: {
		type: "obj number_display", 
		init: "object('number_display', 27+48+8, 27+10+2, {field: 'coins', prefix: ~$~})", //8, center the text a bit, not in the original ui. Rest is magic centering numbers.
		persistent: false,
	},
	gui_boss_progress_display: {
		type: "obj boss_progress_display", 
		init: "object('boss_progress_display', 27+0, 27+level.camera_position[3], {})",
		persistent: false,
	},		
	set_up_gui: "def() -> commands [
		tear_down_gui(), //The set-up event is fired twice in some cases. In that case; simply resetup the gui.
		
		map(components.default + if(IPHONE_SYSTEM, components[control_scheme], []),
			'gui_element', [
				remove_object(gui_element), //We don't want duplicate gui objects. Since it's very hard to only fire setup once, we'll just remove any objects that find their way into the level twice. Note - this won't work if the event is called twice in the same event handler, but it will work fine if called in different event handlers.
				add_object(gui_element),
			]
		) where components = {
			default: [gui_heart_display, gui_ability_display, gui_mana_display, gui_boss_progress_display]
				+ if(not not find(level.active_chars, value.type in ['level_controller_neverending', 'level_controller_neverending_vertical']), //Test if we're on a score-based arcade level.
					[gui_score_display, gui_highest_score_display], //Arcade displays score/best score,
					[gui_coins_display]), //but normal play just displays coins got, unless we're on the coin arcade level.
			ipad_2d: [/*mobile controls here*/],
			iphone_2d: [],
		},
	]",
		
	tear_down_gui: "def() -> commands
		map([gui_heart_display, gui_ability_display, gui_mana_display, gui_coins_display, gui_boss_progress_display], 
			remove_object(value))
	", 


#-------------------------- constants --------------------------#
		
	light_radius: "60",
	jump_power: "1200",
	jump_boost: "90",
	jump_glide: "if(not is_currently_fat, 30, 20)", //20: But keep this where it is.
	walk_accel: "1600",
	roll_accel:  "2200",
	run_accel:  "2800",
	
	tongue_length: "int <- 14 + number_of_item('tongue_extension')*6",
	spit_power: "80",
	posthit_invicibility_period: "50",
	
	jump_out_of_water_boost: "1400",
	jump_out_of_water_boost_horizontal: "200",
	
#-------------------------- vars --------------------------#
		#-- player state --#
	is_currently_fat: { type: "bool", default: false},
	current_ability: { type: "int", default: 0 },
	ability_list: { type: "[string]", default: ["tongue"] },
	
	swallowed_object: { type: "obj throwable|null", default: null},
	
		#-- items and achievements --#
	enemies_tasted: { type: "{string -> bool}|null", default: null }, //A running tally of how many of what kind of enemy we have tasted. Used for the Frogourmet achivement.
	items_carried: { type: "{string -> int}", default: {"tongue" : 1} }, //Used to keep track of what items we have. Access via has_item, add_item, etc.

	num_partial_hearts: { type: "int", default: 0 }, //Used by partial_max_heart_object.cfg
	name: "'Frogatto'",  //intended for use in dialogues; if we need to do string substitution at some point when we have multiple characters
	
	_jump_cheat: { type: "bool", default: false },

	starting_systemclock_time_of_entire_playthrough: { type: "int|null", default: null },

#-------------------------- temporary vars --------------------------#
	_bounced_on_chain: { type: "int", default: 0, persistent: false },
	_last_bounced: { type: "int", default: 0, persistent: false },
	last_landed_hard: { type: "int", default: -30, persistent: false },
	is_running: { type: "bool", default: false, persistent: false },
	_tongue_tip: { type: "custom_obj|null", default: null, persistent: false },

	//indicates whether the last press of jump was while in the air.
	pressed_jump_in_air: { type: "bool", default: false, persistent: false },
	pressed_jump_on_cycle: { type: "int", default: 0, persistent: false },

	started_using_ability_at_cycle: { type: "{ string -> int }", default: { "tongue": 0 }, persistent: false },
	ctrl_left_counter: { type: "int", default: 0, persistent: false },
	ctrl_right_counter: { type: "int", default: 0, persistent: false },
	ctrl_attack_counter: { type: "int", default: 0, persistent: false },
	ctrl_tongue_counter: { type: "int", default: 0, persistent: false },
	last_played_fire_sfx: { type: "int", default: 0, persistent: false },
	idleness_counter: { type: "int", default: 0, persistent: false },
	idleness_level: { type: "int", default: 0, persistent: false },

	in_solidity_fail: { type: "int|null", default: null, persistent: false },
	
	bubbles_die_here: { type: "int", default: 0, persistent: false },


#-------------------------- stuff that should be removed --------------------------#
	coin_race_levels: { type: "[string]", default: [] },
},

  
	  
on_hax: "hax_",

//give frogatto brief invincibility when we load
on_load: "[
	set_up_gui(),
	if(not lights, set(lights, [circle_light(me, light_radius)])),
	set(invincible, 50),
	set(brightness, 255),
	set(started_using_ability_at_cycle, fold(map(mana_cooldown_time, {(key): -value}), a+b)),
]",

on_create: "[
	set_up_gui(),
	set(lights, [circle_light(me, light_radius)]), 
	animation('stand'),
]",

on_enter_level: "[
	set_up_gui(),
	proto_event('player_controlled_platformer_character','enter_level'),
	
	//Tracking, used for some events and displaying a metric of progress for saved games.
	if(not level.id in levels_visited, add(levels_visited, [level.id])),
	
	//Clear left-over state from the last level.
	animation('stand'),
	set(rotate, 0),
]",

on_load_checkpoint: "[
	set_up_gui(),
	gui_boss_progress_display.reset(),
	
	if((not lights), set(lights, [circle_light(me, light_radius)])),
	set(hitpoints, (max_hitpoints*4-difficulty)/4),
	set(score, (score*9)/10),

	//Make it so that if we had a swallowed object we create a fresh version of the object in our stomach.
	if(swallowed_object, [
		set(obj.variations, swallowed_object.variations),
		set(swallowed_object, (obj throwable <- obj)),
		fire_event(obj, 'swallowed')
		] where obj = object(swallowed_object.type, midpoint_x, midpoint_y, facing)
	),
	
	set(started_using_ability_at_cycle, fold(map(mana_cooldown_time, {(key): -value}), a+b)),

	animation('stand'),
	set(velocity_x, 0),
	set(velocity_y, 0),
	move_to_standing(),
	set(brightness, 255),

	schedule(2, fire_event('check_water'))
]",

//Remove the gui so it does not panic when we, ourself, are removed.
on_being_removed: "tear_down_gui()",

on_enter_start_jump_anim: "choose_sfx('jump')",

on_enter_slide_anim: "[
	set(rotate, 0),
	if(IPHONE_SYSTEM, set(underwater_controls, false)),
	set(pressed_jump_in_air, true),
	set(velocity_y, 0),
]",
	  
on_leave_interact_anim: "if(interacting_with, fire_event((object <- interacting_with), 'cancel_interaction'))",

on_leave_jump_attack_anim: "[
	fire_event('leave_attack_anim'),
	set(attached_objects, []),
]",

on_leave_slide_anim: "[
	if(ctrl_left, facing(-1)),
	if(ctrl_right, facing(1)),
]",

on_enter_walk_anim: "[
	set(_bounced_on_chain,0),
]",

on_enter_run_anim: "[
	set(_bounced_on_chain,0),
]",

on_die: "[
	remove_object(_tongue_tip),
	spawn('die_cloud', midpoint_x, midpoint_y, facing),
]",

on_ctrl_jump: "[
	proto_event('player_controlled_platformer_character', 'ctrl_jump'),
	set(pressed_jump_on_cycle, cycle),
	if(animation = 'slide', [
		set(pressed_jump_in_air, false),
		facing(-facing), 
		animation('start_jump'), 
		set(velocity_x, -facing*800), 
		set(velocity_y, -1000),
	], set(pressed_jump_in_air, (not can_jump()))),
]",

on_ctrl_left: "start_moving(-1)",

on_ctrl_right: "start_moving(1)",

on_end_ctrl_left: "stop_moving",

on_end_ctrl_right: "stop_moving",

on_ctrl_down: "if(animation = 'slide', animation('fall'))",

on_ctrl_attack: "set(current_ability, (current_ability+1) % size(ability_list))",
		
on_end_ctrl_up: "if((animation in ['enter_lookup', 'lookup']), start_standing)",

	   
on_start_level: "[
	//proto_event('hittable', 'start_level'),  TODO:  why isn't this working?
	if(level.cycle < time_last_hit, set(time_last_hit, 0)),
	zombie_object_cleanup,
	fire_event('check_water'),
	spawn('shadow_small',mid_x,mid_y,1,set(child.parent, me)),
	
	schedule(2, do_key_check)
]",


on_process: "[
	if(cycle % 2 = 0, [
	if(int(ctrl_right) - int(ctrl_left) != 0 and int(ctrl_right) - int(ctrl_left) != facing, set_facing(-facing)),
	if(ctrl_up and animation in ['stand'], animation('enter_lookup')),
	proto_event('player_controlled_platformer_character', 'timer')]),

	//If we're standing on a springy object, force a collide_feet
	//event to make us bounce off it.
	if(velocity_y = 0 and standing_on and standing_on is obj standard_values, if(standing_on.springiness > 0,
			 fire_event('collide_feet', {collide_with: standing_on}))),
	
	if(is_standing, set(rotate, slope_standing_on/4), if(not animation in jump_animations, set(rotate,0))),
	
	if((not is_standing) and (not underwater),
		add(_cycles_since_last_touching_ground, 1),
		if(cycle - _last_bounced < postjump_grace_period, set(_cycles_since_last_touching_ground, postjump_grace_period), set(_cycles_since_last_touching_ground, 0)), 
	),
	
	if((not is_standing) and should_be_standing,
		animation('fall'),
	),

	if(ctrl_jump and (not ctrl_down) and (not pressed_jump_in_air) and (cycle - pressed_jump_on_cycle < 12 or _jump_cheat),
		add(velocity_y, -jump_boost)),

	if((not is_currently_fat) and underwater and (not _tongue_tip),
		if(IPHONE_SYSTEM, [
			swim(ctrl_x, ctrl_y),
			if((not ctrl_x) and (not ctrl_y), float()),
			if(ctrl_x < 0 and facing > 0 or ctrl_x > 0 and facing < 0, set(facing, -facing)),
		],[
			swim(
				(int(ctrl_right) - int(ctrl_left))*if(ctrl_down or ctrl_up, 700, 1000), 
				(int(ctrl_down) - int(ctrl_up))*if(ctrl_left or ctrl_right, 700, 1000) ),
			if((not ctrl_left or ctrl_right or ctrl_up or ctrl_down) and animation in ['swim_side','swim_up','swim_down'],
				float()),
		])
	),

	[if(ctrl_left, process_movement(-1)), if(ctrl_right, process_movement(1))],
	if(should_continue_roll(facing), process_movement(facing), if(animation = 'roll' and (not (ctrl_left or ctrl_right)), stop_moving)),
	if(ctrl_down and (not (ctrl_left or ctrl_right)), crouch()),

	if(animation in attack_animations + ['turn'], maintain_locomotion),
	
	if(ctrl_tongue, add(ctrl_tongue_counter,1), set(ctrl_tongue_counter, 0)),
	if(ctrl_attack, add(ctrl_attack_counter,1), set(ctrl_attack_counter, 0)),

	if(not mana_shock_active, add(mana, mana_regen_per_frame)),
	use_mana_cooldowns(),
	
	track_key('i'),
	if(ctrl_keyboard('i') = 1, suspend_level('inventory-screen.cfg') ),
	
	if(ctrl_tongue, attack()),
]",

on_process_start_jump: "[set_aerial_rotation(-2)]",
	
on_process_jump: "[if(velocity_y > 0, animation('fall')),set_aerial_rotation(-1)]",
	
on_process_fall: "[
	if(IPHONE_SYSTEM,
		if(underwater_controls, [
			add(velocity_x, (jump_glide*ctrl_x)/1000),
			add(velocity_y, (jump_glide*ctrl_y)/1000), 
		])
	),
	set_aerial_rotation(-1),
	proto_event('player_controlled_platformer_character', 'process_fall')]",

on_leave_fall_anim: "set(rotate,0)",
	
on_process_lookup: "[
	add(lookup_time, 1),
	if(lookup_time = 50, set(vertical_look, -200)),
]",

on_process_crouch: "[
	add(lookdown_time, 1), 
	if(lookdown_time = 50, set(vertical_look, 200)),
]",

on_leave_lookup_anim: "[
	set(lookup_time, 0), 
	set(vertical_look, 0),
]",

on_leave_crouch_anim: "[
	set(lookdown_time, 0), 
	set(vertical_look, 0),
]",


on_process_slide: "if(not can_slide, animation('fall'))",

on_check_water: "[
	if(underwater and (not is_currently_fat), float()),
]",

on_enter_water: "[
	sound('water-enter.ogg'),
	set(bubbles_die_here, me.midpoint_y),
	
	//TODO: Do we want underwater controls so soon?
	if(IPHONE_SYSTEM, set(underwater_controls, true)),
	if(not is_currently_fat or _tongue_tip, float()), //Calling float removes feet, too.
	
	//splash if we are entering the water with reasonable velocity
	if(water_bounds != null and velocity_y > 200, [
		spawn('water_splash', midpoint_x, water_bounds[1]+10, if(1d2=2,facing,-facing)),
		spawn('water_particles', midpoint_x, water_bounds[1]+10, facing),
	]),
]",

on_exit_water: "[
	set(has_feet, true),
	animation('fall'),
	sound('water-exit.ogg'),
	schedule(60, fire_event('check_water')),
	
	if(velocity_y < -200, [
		spawn('water_splash', midpoint_x, previous_water_bounds[1]+10, choose([facing,-facing])),
		spawn('water_particles', midpoint_x, previous_water_bounds[1]+10, facing),
	]),
	
	if(velocity_y < 0, add(velocity_y, -jump_out_of_water_boost)),
	set(velocity_x, (velocity_x*jump_out_of_water_boost_horizontal)/100),
]",


on_collide_feet: "[
	if(IPHONE_SYSTEM and (not underwater), set(underwater_controls, false)),

	schedule(8,fullfill_todo_upon_landing),

	if(animation = 'freefall', [animation('faceplant'),set(velocity_x,0)],
		if(arg.collide_with is obj standard_values and (obj standard_values <- arg.collide_with).springiness > 0, [
			bounce_on(obj standard_values <- arg.collide_with),
		],[	
			set(velocity_x, velocity_x/2),
			if(has_feet and animation not in uninterruptible_animations,
				[if(velocity_y > 1300, [animation('land'),sound('bumphead-light.wav',0.5)], start_standing),
				if(velocity_y>900,choose_sfx('jump'),choose_sfx('footfall')),
			
				if((hypot(velocity_x,velocity_y) > 1500) and (abs(velocity_x) > 700), set(last_landed_hard, cycle))
				],
			),
		]),
	)
]",

on_collide_head: "[
	if(animation in ['start_jump', 'jump'], animation('bumphead')), 
	if(velocity_y < 0, set(velocity_y, 0)),
	set(pressed_jump_in_air, true),
]",

on_collide_side: "[
	set(velocity_x, 0),
	if(animation in ['start_jump', 'jump', 'fall']
			and can_slide
			and (abs(velocity_x) > 200 or ctrl_jump and pressed_jump_in_air), [
		animation('slide'),
		set(velocity_y, 0),
		sound('wall-catch'+1d5+'.wav'),
	]),
]",
	   
on_collide_object_body: "
	if(arg.collide_with_area in ['attack','thrown'], if(arg.collide_with is obj hittable, if( true /*((not (obj hittable <- arg.collide_with).spat_out_at)
			or (obj hittable <- arg.collide_with).spat_out_at < level.cycle - 20)*/ and (obj hittable <- arg.collide_with).team != team and (obj hittable <- arg.collide_with).team != 'evil_harmless',
		if(not is_invincible, get_hit_by((obj hittable <- arg.collide_with))))),
		if(arg.collide_with_area = 'interact', set(can_interact, true)) ) //If it wasn't the attack area that hit our body, respond to other areas. See if we're colliding with another object's interact area, in which case we set it so we can interact with them.
",

//if we couldn't return an object to play when spitting it, revert to having it inside us.
on_add_object_fail: "if(arg.object and swallowed_object = null, [
	add(gravity_shift, -arg.object.carry_gravity) asserting arg.object is obj throwable,
	set(swallowed_object, arg.object) asserting arg.object is obj throwable,
	add(variations, ['fat']), set(is_currently_fat, true),
])",

//If we change our solid dimensions -- i.e. try to come back from being hurt, and we can't because we're on top of another solid object, then we take more damage.
on_change_solid_dimensions_fail: "[
	proto_event('player_controlled_platformer_character', 'change_solid_dimensions_fail'),
	if(not is_invincible_posthit, if(is_currently_fat, shoot_spit_attack, animation('hurt')) ),
]",


on_end_enter_crouch_anim: "animation('crouch')",

on_end_crouch_anim: "if(ctrl_down, animation('crouch'), animation('leave_crouch'))",

on_end_leave_crouch_anim: "start_standing",

on_enter_turn_whilst_running_anim: "if((not underwater), [
	map(range(4), schedule(value*3, bind_command( def() spawn_on_ref('dust_cloud_skid', midpoint_x -7*facing, y2-6, facing)))),
])",

on_enter_skid_anim: "if(abs(velocity_x) > 300 and (not underwater), [
	map(range(4), schedule(value*3, bind_command( def() spawn_on_ref('dust_cloud_skid', midpoint_x -7*facing, y2-6, facing)))),
	choose_sfx('slide'),
])",

on_enter_land_anim: "if(not underwater, [
	spawn_on_ref('dust_cloud_skid', midpoint_x + 20*facing, y2 - 8,  facing), 
	spawn_on_ref('dust_cloud_skid', midpoint_x - 20*facing, y2 - 8, -facing),
])",


on_end_turn_anim: "start_standing",
on_end_start_jump_anim: "animation('jump')",
on_end_jump_anim: "animation('jump')",
on_end_fall_anim: "animation('fall')",
on_end_bumphead_anim: "animation('fall')",
on_end_land_anim: "start_standing",
on_end_roll_anim: "animation('roll')",
on_end_stand_to_walk_anim: "animation('walk')",
on_end_walk_anim: "animation('walk')",
on_end_freefall_anim: "animation('freefall')",
on_end_faceplant_anim: "animation('prostrate')",

on_end_run_anim: "animation('run')",
on_process_run: "if(abs(velocity_x) > 300 and cycle%5=0 and (not underwater),
	spawn_on_ref('dust_cloud_run', midpoint_x - 30*facing, y2-10, -facing))",

//note:  using level.zoom to detect if in a cutscene or dialogue, in which case we don't do idle anims.
//TODO:  this fails to account for the epilogue.  Figure out some way to do this without setting a special tracker variable, since those are bug-prone.
on_end_stand_anim: "if((not is_currently_fat) and idleness_counter > 8 and level.zoom = 1, 
	[fire_event('idling'), set(idleness_counter, 0)],
	[animation('stand'), add(idleness_counter, 1)],
)",
	
on_leave_stand_anim: "[set(idleness_counter, 0), set(idleness_level, 0)]",
on_end_skid_anim: "start_standing",

on_idling: "if(idleness_level < 6, [
	animation('stand'),
	add(idleness_level, 1),
],[
	if(1d4!=4, animation('idle_croak'), animation('idle_eyeball')),
	set(idleness_level, 0),
])",
					
on_end_idle_eyeball_anim: "start_standing",
on_end_idle_croak_anim: "start_standing",

on_footfall: "choose_sfx('footfall')",
on_swim_stroke: "sound('water-swim'+1d4+'.wav')",

on_end_spit_anim: "if(underwater, float(), start_standing)",



					  

on_process_attack: "if(facing = 1 and ctrl_right or facing = -1 and ctrl_left, [
	set(animation, 'walk_attack'),
	set(time_in_animation, time_in_animation), //This carries the time in animation over to walk_attack. First we set the animation, which sets time_in_animation to 0, then we run the set() command, which sets time in animation to whatever the old time_in_animation was, when we evaluated the command. It is, contrary to appearances, not just a tautological operation.
	set(accel_x, walk_accel),
])",
on_process_walk_attack: "if(facing = 1 and (not ctrl_right) or facing = -1 and (not ctrl_left), [
	set(animation, 'attack'), 
	set(time_in_animation, time_in_animation), //See comment in on_process_attack.
])",
on_end_walk_attack_anim: "animation('walk')",

on_end_energyshot_anim:            "start_standing",
on_end_energyshot_jump_anim:       "start_standing",
on_end_energyshot_up_slope_anim:   "start_standing",
on_end_energyshot_down_slope_anim: "start_standing",

on_end_floating_spin_anim: "animation('floating_spin')",
on_end_floating_spin_fast_anim: "animation('floating_spin_fast')",
on_end_floating_spin_faster_anim: "animation('floating_spin_faster')",

on_end_attack_anim: "[
	if(('fat' in variations), animation('swallow')),
	start_standing,
]",
on_leave_attack_anim: "[
	if(_tongue_tip, fire_event('remove_tongue')), 
	set(attached_objects, []),
]",

on_end_swallow_anim: "start_standing",
on_end_enter_lookup_anim: "animation('lookup')",
on_end_lookup_anim: "animation('lookup')",
on_end_jump_attack_anim: "animation('fall')",
on_end_firebreath_begin_anim: "animation('firebreath_cycle')",
on_end_firebreath_cycle_anim: "if(shoot_fire_active,animation('firebreath_cycle'), animation('firebreath_end'))",
on_end_firebreath_end_anim: "start_standing",
on_end_acidbreath_begin_anim: "animation('acidbreath_cycle')",
on_end_acidbreath_cycle_anim: "animation('acidbreath_end')",
on_end_acidbreath_end_anim: "start_standing",
on_end_swim_side_idle_anim: "float()",
on_end_swim_side_anim: "if(underwater, animation('swim_side'), start_standing)",
on_end_swim_up_anim:   "if(underwater, animation('swim_up'),   start_standing)",
on_end_swim_down_anim: "if(underwater, animation('swim_down'), start_standing)",
on_end_item_get_begin_anim: "animation('item_get_hold')",
on_end_item_get_hold_anim: "animation('item_get_hold')",
on_end_item_get_end_anim: "animation('stand')",
on_end_hurt_anim: "animation(if((not is_currently_fat) and underwater, 'swim_side_idle', 'stand'))",

on_end_emote_geez_anim: "animation('stand')",
on_end_emote_oh_anim: "animation('stand')",
on_end_emote_impatient_anim: "animation('stand')",
on_end_emote_raisedfinger_anim: "animation('stand')",
on_end_emote_confused_anim: "animation('stand')",
on_end_emote_talk_anim: "animation('stand')",
on_end_emote_nod_anim: "animation('stand')",
on_end_emote_angry_anim: "animation('stand')",
on_end_emote_victory_anim: "animation('emote_victory2')",
on_end_emote_victory2_anim: "animation('stand')",
on_end_descend_rope_anim: "animation('descend_rope')",

animation: [
	{
		"@base": true,
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
	},
#-------------------------- standing animations --------------------------#
	{
		image: "characters/frogatto-spritesheet1.png",
		id: "stand",
		duplicates: 6,
		rect: [2,89,33,121],
		frames: 11,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "stand", //blink variant
		rect: [2,125,33,157],
		frames: 11,
		duration: 4,
	},
#-------------------------- movement animations --------------------------#
	{
		image: "characters/frogatto-spritesheet1.png",
		id: "stand_to_walk",
		rect: [439,91,470,123],
		frames: 2,
		frames_per_row: 1,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "walk",
		solid_area: [17,19,31,41],
		rect: [1,352,48,399],
		frames: 12,
		frames_per_row: 4,
		duration: 3,
		events: "6:24:footfall",
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "run",
		solid_area: [17,19,31,41],
		rect: [219,352,266,399],
		frames: 12,
		frames_per_row: 4,
		duration: 2,
		events: "6:18:footfall",
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "skid",
		x: 478, y: 91, w: 32, h: 33,
		frames: 5,
		frames_per_row: 1,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "turn",
		x: 317, y: 2, w: 32, h: 33,
		frames: 2,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "turn_whilst_running",
		solid_area: [17,19,31,41],
		rect: [1,386,48,433],
		frames: 7,
		duration: 3,
	},
#-------------------------- jumping and aerial animations --------------------------#
	{
		image: "characters/frogatto-spritesheet7.png",
		id: "start_jump",
		solid_area: [9,13,23,35],
		x: 1,
		y: 103,
		w: 32,
		h: 48,
		frames: 5,
		duration: 3,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "jump",
		solid_area: [9,13,23,35],
		x: 1, y: 1, w: 32, h: 48,
		frames: 5,
		reverse: true,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "fall",
		solid_area: [9,13,23,35],
		x: 1, y: 52, w: 32, h: 48,
		duration: 2,
		frames: 12,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "land",
		solid_area: [9,17,23,39],
		x: 142, y: 38, w: 32, h: 48,
		duration: 4,
		frames: 2,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "roll",
		x: 1, y: 154, w: 32, h: 33,
		duration: 3,
		frames: 8,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_y: 0,
		id: "slide", //wallcling
		x: 352, y: 40, w: 32, h: 34,
		duration: 30,
		frames: 1,
		solid_area: [14,8,28,30],
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "bumphead",
		sound: "bumphead.wav",
		solid_area: [9,12,23,34],
		rect: [422,2,453,36],
		duration: 5,
		frames: 1,
	},	
#-------------------------- misc/utility animations --------------------------#
	{
		image: "characters/frogatto-spritesheet1.png",
		id: "lookup",
		rect: [37,233,68,265],
		frames: 1,
		duration: 3,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "enter_lookup",
		rect: [2,233,33,265],
		frames: 1,
		duration: 3,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "crouch",
		solid_area: [9,17,23,30],
		rect: [107,197,138,229],
		frames: 1,
		duration: 1,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "enter_crouch",
		solid_area: [9,17,23,30],
		rect: [2,197,33,229],
		frames: 3,
		duration: 3,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "leave_crouch",
		rect: [2,197,33,229],
		frames: 3,
		duration: 3,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "hurt",
		rect: [271,351,303,383],
		frames: 1,
		duration: 18,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "interact",
		collide_x: 10,
		collide_y: 6,
		collide_w: 15,
		collide_h: 16,
		feet_x: 16,
		feet_y: 32,
		x: 72, y: 161, w: 32, h: 33,
		frames: 4,
		duration: 4,
		reverse: true,
		events: "15:interacting",
	},
#-------------------------- spit/tongue attack animations --------------------------#
	{
		image: "characters/fat-frogatto-spritesheet1.png",
		id: "swallow",
		x: 2, y: 269, w: 49, h: 38,
		duration: 6,
		frames: 6,
		solid_area: [6,13,20,35],
	},{
		image: "characters/fat-frogatto-spritesheet1.png",
		id: "spit",
		x: 314, y: 269, w: 34, h: 35,
		duration: 3,
		frames: 3,
		solid_area: [6,8,20,30],
	},{
		image: "characters/frogatto-spritesheet5.png",
		id: "attack",
		sound: "tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav",
		rect: [2,151,33,188],
		solid_area: [9,12,23,34],
		frames: 8,
		duration: 2,
		reverse: false,
	},{
		image: "characters/frogatto-spritesheet5.png",
		id: "walk_attack",
		rect: [2,233,33,270],
		solid_area: [9,12,23,34],
		frames: 4,
		duration: 4,
		reverse: false,
	},{
		image: "characters/frogatto-spritesheet5.png",
		id: "jump_attack",
		sound: "tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav",
		rect: [2,192,50,229],
		solid_area: [16,10,30,32],
		frames: 8,
		duration: 2,
		reverse: false,
	},
#-------------------------- special ability animations --------------------------#
	{
		image: "characters/frogatto-spritesheet1.png",
		id: "firebreath_begin",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "firebreath_cycle",
		rect: [360,476,393,510],
		frames: 2,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "firebreath_end",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "acidbreath_begin",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "acidbreath_cycle",
		rect: [360,476,393,510],
		frames: 2,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "acidbreath_end",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet2.png",
		id: "energyshot_jump",
		rect: [1,415,41,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [12,14,26,36],
	},{
		image: "characters/frogatto-spritesheet2.png",
		id: "energyshot_down_slope",
		rect: [45,415,85,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,15,28,37],
	},{
		image: "characters/frogatto-spritesheet2.png",
		id: "energyshot_up_slope",
		rect: [89,415,129,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,15,28,37],
	},{
		image: "characters/frogatto-spritesheet2.png",
		id: "energyshot",
		rect: [133,415,173,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,14,28,36],
	},
#-------------------------- underwater animations --------------------------#
	{
		image: "characters/frogatto-spritesheet2.png",
		accel_y: 0,
		id: "swim_side_idle",
		x: 3, y: 85, w: 39, h: 36,
		frames: 6,
		frames_per_row: 3,
		duration: 6,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_y: 0,
		id: "swim_down_idle",
		x: 129, y: 85, w: 39, h: 36,
		frames: 6,
		frames_per_row: 3,
		duration: 6,
		reverse: true,
		solid_area: [12,8,26,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_y: 0,
		id: "swim_up_idle",
		x: 255, y: 85, w: 39, h: 36,
		frames: 6,
		frames_per_row: 3,
		duration: 6,
		reverse: true,
		solid_area: [12,8,26,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_y: 0,
		id: "swim_side",
		events: "15:swim_stroke",
		x: 3, y: 163, w: 39, h: 36,
		frames: 3,
		duration: 10,
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_y: 0,
		id: "swim_down",
		events: "15:swim_stroke",
		x: 129, y: 163, w: 39, h: 36,
		frames: 3,
		duration: 10,
		solid_area: [12,8,26,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_y: 0,
		id: "swim_up",
		events: "15:swim_stroke",
		x: 255, y: 163, w: 39, h: 36,
		frames: 3,
		duration: 10,
		solid_area: [12,8,26,30],
	},
#-------------------------- cinematic/item/victory animations --------------------------#
	{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_begin",
		rect: [1,335,32,367],
		frames: 4,
		duration: 10,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_hold",
		rect: [106,335,137,367],
		frames: 1,
		duration: 30,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_end",
		rect: [1,335,32,367],
		frames: 4,
		duration: 10,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_geez",
		rect: [1,1,36,38],
		solid_area: [11,13,25,35],
		frames: 8,
		reverse: true,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet4.png",
		id: "emote_oh",
		rect: [1,1,36,38],
		solid_area: [11,13,25,35],
		frames: 15,
		frames_per_row: 5,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_confused",
		rect: [1,52,36,89],
		solid_area: [11,13,25,35],
		frames: 14,
		frames_per_row: 7,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_impatient",
		rect: [323,1,358,38],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 4,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_raisedfinger",
		rect: [1,144,36,181],
		solid_area: [11,13,25,35],
		frames: 14,
		frames_per_row: 7,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_talk",
		rect: [1,236,36,273],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 8,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_nod",
		rect: [323,175,358,212],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 4,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet4.png",
		id: "emote_angry",
		rect: [1,127,36,164],
		solid_area: [11,13,25,35],
		frames: 20,
		frames_per_row: 5,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet-idle.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "idle_eyeball",
		rect: [1,1,32,33],
		frames: 43,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet-idle.png",
		accel_x: 0,
		accel_y: 0,
		pad: 7,
		body_area: "all",
		feet_width: 5,
		id: "idle_croak",
		rect: [3,37,34,69],
		frames: 25,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "floating_spin",
		rect: [3,436,34,477],
		frames: 8,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "floating_spin_fast",
		rect: [3,436,34,477],
		frames: 8,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "floating_spin_faster",
		rect: [3,436,34,477],
		frames: 8,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet6.png",
		id: "emote_victory",
		rect: [1,1,33,33],
		solid_area: [10,6,24,28],
		frames: 18,
		frames_per_row: 9,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet6.png",
		id: "emote_victory2",
		rect: [73,73,105,105],
		solid_area: [10,6,24,28],
		frames: 7,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "freefall",
		rect: [469,1,510,48],
		solid_area: [14,16,28,38],
		reverse: true,
		frames: 3,
		frames_per_row: 1,
		duration: 3,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "faceplant",
		rect: [1,277,42,324],
		solid_area: [14,16,28,38],
		frames: 9,
		duration: 3,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "prostrate",
		rect: [361,277,402,324],
		solid_area: [14,16,28,38],
		frames: 1,
		duration: 3,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "descend_rope",
		rect: [443,369,474,401],
		frames: 8,
		frames_per_row: 2,
		duration: 5,
		accel_y: 0,
		play_backwards: true,
		velocity_y: 200,
	}],


variations: {
	fat: "[
		map(filter(doc.animation, value.image in images_to_convert), 'anim',
		set(anim.image, regex_replace(anim.image, 'frogatto', 'fat-frogatto'))) where
		images_to_convert = ['characters/frogatto-spritesheet1.png',
							 'characters/frogatto-spritesheet3.png',
							 'characters/frogatto-spritesheet4.png',
							 'characters/frogatto-spritesheet7.png'],
		map(filter(doc.animation, value.id = 'walk'), 'anim', set(doc.anim.accel_x, 1300)),
		map(filter(doc.animation, value.id = 'run'), 'anim', set(doc.anim.accel_x, 1900)),
	]",
},



object_type: [
	#-------------------------- TONGUE/HEAD --------------------------#
	{
		id: "tongue_shaft",
		always_active: true,
		serializable: false,
		zsub_order: 5,
		solid_dimensions: [],
		is_strict: true,
		
		properties: {
			_x_1: { type: "decimal", init: "mid_x" },
			_x_2: { type: "decimal", init: "mid_x+1" },
			_y_1: { type: "decimal", init: "mid_y" },
			_y_2: { type: "decimal", init: "mid_y+1" },

			is_player_body_part: true,
			length: "decimal :: lib.math.length(_x_1,_y_1,_x_2,_y_2)",
			set_ends: "def(decimal new_x1, decimal new_y1, decimal new_x2, decimal new_y2) -> commands [set(_x_1,new_x1), set(_y_1,new_y1), set(_x_2,new_x2), set(_y_2,new_y2), fire_event(me,'create')]",
		},
		
		on_create: "[
				set(mid_x, int((_x_2+_x_1)/2)),
				set(y, int((_y_2+_y_1)/2 - (length/2))),
				set(draw_area, [0, 0, img_w/2, length/2]),
				set(rotate,(angle(_x_1,_y_1,_x_2,_y_2)-90) )
			]",
			
		animation: {
			id: "default",
			image: "characters/frogatto-tongueB.png",
			rect: [0,0,7,7],
			frames: 1,
			no_remove_alpha_borders: true,
		},
	},
	
	
	{
		id: "frogatto_head",
		serializable: false,
		
		properties: {
			is_player_body_part: true,
			_tongue_angle: {type: "int", default: 0},
		},
		
		on_create: "switch(_tongue_angle,
						-90,	animation('up'),
						-45,	animation('updiag'),
						0,		animation('side'),
						45,		animation('downdiag'),
						90,		animation('down'))",
		
		animation: [
			{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "up",
				rect: [2,1,35,26],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "updiag",
				rect: [2,30,35,55],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "side",
				rect: [2,59,35,84],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "downdiag",
				rect: [2,88,35,113],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "down",
				rect: [2,117,35,142],
			},
		],
	},
	
	
	{
		id: "tongue_tip",
		prototype: ["hittable"],
		always_active: true,
		serializable: false,
		zsub_order: 6,
		solid_dimensions: ["player","common","boss","thrown"],
		collide_dimensions: ["player","enemy","~key","item"],
		is_strict: true,

		
		properties: {
			is_player_body_part: true,
			attack_damage: "0",
			team: "'player'",
			yhead_offset: "12",
			ybase_offset: "8",
			x_offset: "0*facing",
			tongue_duration: "16",
			damage_cooldown: "10",
			max_swallow_size: "16",
			min_swallow_size: "10",

			length_per_time: "def(int time) -> int _frog.tongue_length*(tongue_duration/2 - abs(tongue_duration/2 - time))",
			set_shaft: "def(int time, decimal angle) -> commands [	_shaft.set_ends(	_froghead.mid_x + x_offset,
																_froghead.mid_y + ybase_offset,
																_froghead.mid_x + (length_per_time(time)*cos(angle)) * facing + x_offset,
																_froghead.mid_y + ybase_offset + (length_per_time(time)*sin(angle))  )]",
			adjust_position: "def(int time, decimal angle) -> commands	[set(midpoint_x, int(_froghead.midpoint_x + (length_per_time(time)*cos(angle)) * facing  + x_offset + if(facing = 1, 2,0))), 
												set(midpoint_y, int(_froghead.midpoint_y + ybase_offset + (length_per_time(time)*sin(angle)) + if(facing = -1 and angle = 0, -1, 0) )),
												set(rotate, angle * facing)]",
			process_tongue: "def() -> commands [set_shaft(_timer, _tongue_angle),adjust_position(_timer,_tongue_angle),if(_timer >= tongue_duration,die()),fire_event('drag_victim'),if(_timer = tongue_duration/2, animation('flash')),add(_timer,1)]",
			
			#-------------------------- vars --------------------------#
			_timer: {type: "int", default: 1},
			_tongue_angle: {type: "int", default: 0},
			_last_x: {type: "int", default: 0},
			_last_y: {type: "int", default: 0},
			_swallowed: {type: "obj throwable|null", default: null},
			_cycle_grabbed: {type: "int|null", default: null},

			_frog: {type: "obj frogatto_playable", persistent: false},
			_froghead: {type: "obj frogatto_playable.frogatto_head", persistent: false, init: "object('frogatto_playable.frogatto_head', x, mid_y - 12, {facing: facing})" },  #TODO:  this can't be valid here, because it's not from the initialization_map by the time we get here 
			_shaft: {type: "obj frogatto_playable.tongue_shaft", persistent: false, init: "object('frogatto_playable.tongue_shaft',x,y, {facing: 1})" },
		},
		
		
		on_spawned: "set(parent, arg.spawner)",
		on_create:  "[	set(_froghead.facing, facing),
						add_object(_froghead),
						add_object(_shaft),
						set(_froghead._tongue_angle,_tongue_angle),
						set(_froghead.parent,parent),
						fire_event(_froghead, 'create'),
						set(_froghead.relative_x,0),
						set(_froghead.relative_y,-12),
						animation('initial')] asserting parent is obj frogatto_playable",
		
		
		
		on_draw: "process_tongue()",
		
		on_die: "[
			if(_swallowed and _swallowed.physical_size > 8, [
				set(_frog.swallowed_object, _swallowed),
				add(_frog.variations, ['fat']),
				set(_frog.is_currently_fat, true),
				fire_event(_frog,'end_attack_anim'),
			]),
			set(_shaft.hitpoints, 0), 
			//set(_shaft, null),
			set(_froghead.hitpoints, 0), 
			//set(_froghead, null), 
			set(_frog._tongue_tip, null), 
			if((not _swallowed) and _frog.underwater, set(_frog.has_feet, false)),
		]",

		// If we snag something early, fast-forward us to where the tongue is at the same position, but retracting.
		on_stopearly: "[
			set(_timer, newtime), 
			set(_frog.time_in_animation,newtime),
		] where newtime = _timer + 2*abs(max((tongue_duration/2 - _timer), 0))",
		
		on_drag_victim: "[
			if(_swallowed and _cycle_grabbed and (level.cycle - _cycle_grabbed > 1), [
				set(_swallowed.midpoint_x, _last_x),
				set(_swallowed.midpoint_y, _last_y),
			]),
			set(_last_x, midpoint_x), set(_last_y, midpoint_y),
		]",
						
		on_grab_objects: "if((not _swallowed) and collide_obj.hitpoints, [
			remove_object(collide_obj),
			[
				if(collide_obj is obj padlock_key, set((obj padlock_key <- throwable_obj).valid_levels, collide_obj.valid_levels)),
				set(attached_objects, [throwable_obj]), set(_cycle_grabbed, level.cycle),
				fire_event(throwable_obj, 'been_grabbed'),
				fire_event(throwable_obj, 'swallowed'),
				set(_swallowed, throwable_obj),
				set(throwable_obj.event_handlers, collide_obj.event_handlers),
				if(collide_obj is obj throwable, set(throwable_obj.juggled, (obj throwable <- collide_obj).juggled)),
			
				if(collide_obj.physical_size > 8,[  //things below this get 'consumed' rather than becoming spittable
					add(level.player.gravity_shift, -throwable_obj.carry_gravity),
				],[
					//TODO: I'd like to make these values inherit-via-delegation, rather than be 'unit tested' here to be equivalent, but cannot atm.  I.e. all thrown objects would have a class-only representation of their source type, and could reference its static properties.  I considered making this mutable and setting it, but that's merely to avoid code duplication, and would be much worse due to violating constness.
					null asserting collide_obj.physical_size = throwable_obj.physical_size,
					collide_obj.get_hit_sourceless('neutral', kill_anything),
				]),
			] where throwable_obj = (obj throwable <- object(collide_obj.thrown_type, collide_obj.mid_x, collide_obj.mid_y, {facing: collide_obj.facing, hitpoints: collide_obj.hitpoints, variations: collide_obj.variations, event_handlers:collide_obj.event_handlers})),
			sound('Gulp.wav'),
		]) where collide_obj = obj hittable <- arg.collide_with",
		
		on_collide_object_grab: "
			if(arg.collide_with is obj hittable, if(arg.collide_with_area, if((arg.collide_with_area = 'body' or arg.collide_with_area = 'thrown') and (not _swallowed) and arg.collide_with != level.player, [
				fire_event('stopearly'),
				animation('flashsnag'),
				/*if(tag_ and if(level.player.enemies_tasted, (not tag_ in keys(level.player.enemies_tasted)), true), [
					add(level.player.enemies_tasted, {(tag_): true}),
					//adding 1 since the list won't have been updated yet, plus adding to casual the count of enemies exclusive to the 'challenging' difficulty level, which is only the wartfly, right now.
					if(size(level.player.enemies_tasted) + if(level.player.difficulty >= difficulties.challenging, 1, 2) >= 37, achievement('frogourmet'))
				]) where tag_ = arg.collide_with.frogourmet_tag,*/
				if(is_swallowable,
					[arg.collide_with.play_grabbed_cosmetics,
					
					fire_event('grab_objects', {collide_with: arg.collide_with})], //fire an event to grab the object. We do it in a separate event in case we try to swallow multiple objects at once.
					/*if(arg.collide_with.get_hit_by, arg.collide_with.get_hit_by(me))*/ //object is not swallowable, so do damage to it instead 
				),
			]) where is_swallowable = arg.collide_with.swallowable and arg.collide_with.physical_size <= max_swallow_size))",
		
		on_end_initial_anim: "animation('normal')",
		on_end_flash_anim: "animation('normal')",
		on_end_clung_anim: "animation('clung')",
		on_end_flashsnag_anim: "animation('clung')",
		
		animation: [
			{
				id: "initial",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 4,
				rect: [307,351,339,383],

				//grab_area=solid:all
				grab_area: [8,8,25,20,"solid"],
			},{
				id: "normal",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 100,
				rect: [379,351,411,383],

				//grab_area=solid:all
				grab_area: [8,8,25,20,"solid"],
			},{
				id: "flashsnag",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 2,
				rect: [415,351,447,383],
			},{
				id: "flash",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 2,
				rect: [343,351,375,383],
			},{
				id: "clung",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 100,
				rect: [451,351,483,383],
			},
		],
	},


	#-------------------------- HEAD FOR ENERGYSHOT --------------------------#
	{
		id: "frogatto_head_energyshot",
		serializable: false,
		zsub_order: 12,
		
		properties: {
			is_player_body_part: true,
			_head_angle: { type: "int", default: 0 },
		},
		
		on_spawned: "[set(parent, arg.spawner),set(relative_x,-2),set(relative_y,-7)]",
		
		on_create: "[
			schedule(9,die()),
			switch(_head_angle,
				-90, animation('up'), 
				-45, animation('updiag'), 
				  0, animation('side'), 
				 45, animation('downdiag'), 
				 90, animation('down')
			),
		]",
		
		animation: [
			{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "up",
				rect: [178,415,218,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "updiag",
				rect: [222,415,262,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "side",
				rect: [266,415,306,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "downdiag",
				rect: [310,415,350,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "down",
				rect: [354,415,394,458],
			},
		],
	},
	
	
	#-------------------------- SHOTS --------------------------#
	{
		id: "bubble_shot",
		prototype: ["shot"],
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: false,
			attack_damage: "20",
			damage_cooldown: "10",

			_parent_obj: { type: "obj frogatto_playable", persistent: false },
		},
		
		on_exit_water: "set(velocity_y, 0)",
		on_end_normal_anim: "animation('pop')",
		on_end_pop_anim: "die()",
		
		//Shim for exit_water not firing if we don't have a solid_area.
		on_process: "if(mid_y < _parent_obj.bubbles_die_here, fire_event('exit_water'))",
		
		on_enter_pop_anim: "[
			set(velocity_x,0),
			set(velocity_y,0),
			sound('bubble-pop'+1d5+'.wav'),
			
		]",
		
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 3,
				duration: 8,
				rect: [62,2,71,11],
				attack_area: "all",
			},{
				image: "effects/particles2.png",
				pad: 3,
				id: "pop",
				frames: 2,
				duration: 4,
				rect: [101,2,110,11],
			},
		],
	},

	
	{
		id: "acid_shot",
		dies_on_inactive: true,
		prototype: ["shot"],
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: true,
		on_collide_level: "die()",
		
		on_die: "[proto_event('shot','die'), sound('droplet-burst1.wav'), sound('acid-shot-fizz.wav'), spawn('frogatto_playable.acid_shot_spawner',mid_x+1d20-10, mid_y -1d30, facing)]", 
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: true,
			attack_damage: 15,
			damage_cooldown: 20,
			damage_type: "'acid'",

			_parent_obj: { type: "obj frogatto_playable", persistent: false },
		},
		
		on_spawned: "[
			set(accel_y, 40),
			set(lights, [circle_light(me, 150)]),
			sound('acid-belch'+1d3+'.wav'),
		]",
		on_end_normal_anim: "animation('normal')",
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 3,
				duration: 2,
				reverse: true,

				rect: [108,53,125,70],
				attack_area: "all",
			}
		],
	},
	{
		id: "acid_shot_spawner",
		prototype: ["standard_values"],
		object_level_collisions: false,
		
		properties: {
			max_spread: 128,
			floor_height: "def(int x, int y) -> int|null if(floor_h, floor_h[1], null) where floor_h = _find_floor_standable(x,y,level.player)",
			
			spread_scale: "(_spread/24.0)",
			floor_for_visuals: "floor_height(int(x_for_visuals),mid_y)",
			x_for_visuals: "mid_x+lib.math.round((1d40-20) * spread_scale)",
			
			x_for_damager: "def(int index) -> int lib.math.round(index*60 - lib.math.round(0.8*20)*spread_scale)",
			floor_for_damager: "def(int index) -> int|null floor_height(mid_x+x_for_damager(index),mid_y)",
			
			_spread: { type: "int", default: 0 },
		},

		on_create: "schedule(150,die())",
		on_process:	"[[ if(floor_for_visuals,[
							if(cycle%1=0, spawn('frogatto_playable.acid_secondary_shot',x_for_visuals, floor_for_visuals + 10-1d20, facing)), 
							if(cycle%2=1, spawn('frogatto_playable.acid_secondary_bubble',x_for_visuals, floor_for_visuals -5 -1d20, facing))]), 
						if(cycle%10=0, map(range(lib.math.round(spread_scale*0.8)), if(floor_for_damager(index), spawn('frogatto_playable.acid_shot_damager',mid_x+x_for_damager(index), (int <- floor_for_damager(index)) -1d20, facing)) ))	
						],
					
						if(_spread < max_spread, add(_spread, 4))]",
		animation: [
			{
				image: "effects/particles2.png",
				id: "normal",
				frames: 1,
				duration: -1,
				rect: [127,19,128,20],
			}
		],
	},
	{
		id: "acid_shot_damager",
		dies_on_inactive: true,
		prototype: ["shot"],
		object_level_collisions: false,
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: false,
			attack_damage: 15,
			damage_cooldown: 5,
			damage_type: "'acid'",
		},
		on_create: "schedule(20,die())",
		animation: [
			{
				image: "effects/particles2.png",
				id: "normal",
				frames: 1,
				duration: -1,
				rect: [127,19,128,20],
				attack_area: [-15,-15,15,15,"solid"],
			}
		],
	},
	{
		id: "acid_secondary_shot",
		dies_on_inactive: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		on_create: "[set(velocity_x, 1d20-10),set(velocity_y, -20-1d70)]",
		on_end_normal_anim: "die()",
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 10,
				frames_per_row: 5,
				duration: 5,

				rect: [127,19,133,25],
			}
		],
	},
	{
		id: "acid_secondary_bubble",
		dies_on_inactive: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		on_create: "[set(velocity_x, 1d20-10),set(velocity_y, -40-1d80)]",
		on_end_normal_anim: "die()",
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 8,
				duration: 7,

				rect: [127,39,137,49],
			}
		],
	},
	{
		id: "super_acid_shot_damager",
		dies_on_inactive: true,
		prototype: ["shot"],
		object_level_collisions: false,
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: false,
			attack_damage: 5,
			damage_cooldown: 5,
			damage_type: "'acid'",
		},
		on_process: "if(1d4=4,spawn('frogatto_playable.super_acid_shot_bubble', mid_x + 1d30-15, mid_y + 1d30-15, {facing: if(1d2=2,1,-1), rotate: 1d360}))",

		animation: [
			{
				image: "effects/particles2.png",
				id: "normal",
				frames: 1,
				duration: -1,
				rect: [127,19,128,20],
				attack_area: [-15,-15,15,15,"solid"],
			}
		],
	},
	{
		id: "super_acid_shot_bubble",
		dies_on_inactive: true,
		zorder: "@include data/zorder.cfg:in_front_of_everything",
		object_level_collisions: false,
		
		on_create: "[set(velocity_x, 1d20-10),set(velocity_y, 1d20-10),schedule(30,die())]",
		
		on_process: "set(alpha, lib.math.round(0.90*alpha))",

		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 3,
				duration: 2,
				reverse: true,

				rect: [108,53,125,70],
				attack_area: "all",
			}
		],
	},
	{
		id: "super_acidshot",
		always_active: true,

		properties: {
			circumference_for_circle_of_radius: "def(decimal radius) -> decimal 2.0 * 3.14592 * radius",

			circle_radius: "me.cycle*3",
			width_of_particle: "60",
			time_to_live: "150",

			number_of_particles_per_circle: "decimal :: lib.math.floor(circumference_for_circle_of_radius(circle_radius) / width_of_particle)",
			ang_offset: "def(decimal index) -> decimal 360.0/number_of_particles_per_circle * index",
			position_for_index: "def(int index, int x_base, int y_base) -> {x:decimal, y:decimal} {x: x_base + circle_radius * cos(ang_offset(index)), y: y_base + circle_radius * sin(ang_offset(index))}", 

			position_the_acid_balls: "map(acid_balls, [set(value.x, pos.x), set(value.y,pos.y)] where pos = position_for_index(index, me.mid_x, me.mid_y))",

			acid_balls: {type: "[obj frogatto_playable.super_acid_shot_damager]", default: [] },
			
			grow_acid_ball_set: "if(number_of_particles_per_circle > size(acid_balls), [add(acid_balls, new_acid_balls), map(new_acid_balls, schedule(1,add_object(value)))] where new_acid_balls = map(range(number_of_particles_per_circle - size(acid_balls)), object('frogatto_playable.super_acid_shot_damager', x,y,facing)))",
			
			
		},

		on_create: "[	set(alpha,0),
						schedule(time_to_live, fire_event('clear_objects') ),
						schedule(time_to_live, die())]",

		on_clear_objects: "map(acid_balls, set(value.hitpoints,0))",

		on_process: "[grow_acid_ball_set, position_the_acid_balls]",

	},
	{
		id: "fire_shot",
		prototype: ["shot"],
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: false,
			attack_damage: 50,
			damage_cooldown: 10,
			damage_type: "'fire'",
			
			_parent_obj: {type: "custom_obj", dynamic_initialization: true},
		},
		
		on_spawned: "[
			set(_parent_obj, arg.spawner),
			set(lights, [circle_light(me, 150)]),
			schedule(6,animation('pop')),
		]",
		
		on_end_normal_anim: "animation('normal')",
		on_end_pop_anim: "die()",
		
		on_enter_pop_anim: "[
			set(velocity_x,0),
			set(velocity_y,-200-1d100),
			facing(if(1d2=2,1,-1)),
			set(zsub_order,-10),
		]",
		
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 4,
				duration: 2,

				rect: [2,113,15,130],
				attack_area: "all",
			},{
				image: "effects/particles2.png",
				pad: 3,
				id: "pop",
				frames: 3,
				duration: 2,

				rect: [2,134,15,151],
			},
		],
	},

	{
		id: "super_fireball",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: 500,
		
		properties: {
			attack_damage: "lib.math.round(standard_thrown_damage*(2/3.0))",
			team: "'player'",
			damage_type: "'fire'",
			goes_through_enemy_shots: true,
		},
		
		on_die: "[sound('fire-explode.wav'),spawn('explosion_huge_harmful', mid_x, mid_y, {facing: facing, _shot_by_player: true})]",
		
		on_create: "[
			set(time_in_animation, 1d6),
			sound('fire-stream.wav', 0.6),
			schedule(50,die()),
		]",
	
		on_process: "[
			if(cycle%2 = 1, spawn('explosion_spark', mid_x, mid_y, facing)),
			//set(velocity_x,velocity_x*0.97),
			//set(velocity_y,velocity_y*0.97),
			set(lights, [circle_light(me, wave(cycle*100+1d20)/100)]),
		]",

		
		on_end_anim: "animation('normal')",
		
		animation: {
			body_area: "all",
			attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			rect: [107,74,138,105],
			pad: 3,
			frames: 8,
			frames_per_row: 4,
			duration: 2,
		},
	},
	
	{
		id: "energyshot",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		
		properties: {
			attack_damage: 20,
			team: "'player'",
			damage_type: "'energy'",
			
			_exploded: { type: "bool", default: false },
		},
		
		on_create: "[
			set(time_in_animation, 1d6),
			sound('energyshot.ogg'),
			schedule(50,die()),
			spawn('frogatto_playable.energyshot_bloom',midpoint_x,midpoint_y,0),
			add_particles('particles'),
		]",
	
		on_process: "[
			set(velocity_x,velocity_x*0.97),
			set(velocity_y,velocity_y*0.97),
			set(lights, [circle_light(me, wave(cycle*100+1d20)/100)]),
		]",

		// When we die we want to keep the particles coming. So, we turn into a particle_system_holder object and set our hitpoints to the number of cycles we want to keep the particles running for. We schedule turning into the particle system holder next frame, because we want to remain as we are this frame so any remaining collisions can be properly resolved.
		on_die: "[
			set(hitpoints, 30),
			if((not _exploded), [
				set(_exploded, true), 
				spawn('frogatto_playable.energyshot_bloom',midpoint_x,midpoint_y,0),
				sound('energyshot-impact'+1d5+'.wav'), 
				set(hitpoints, 30), set(particle_systems['particles'].spawn_rate, 0), 
				schedule(0, [
					set(type, 'particle_system_holder'), 
					fire_event('create'),
				])
			])
		]",
		
		on_end_anim: "animation('normal')",
		
		animation: {
			body_area: "all",
			attack_area: [0,0,10,10],
			id: "normal",
			image: "effects/particles2.png",
			x: 3,
			y: 15,
			w: 10,
			h: 10,
			pad: 3,
			frames: 4,
			duration: 2,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			min_y: 3,
			max_y: 5,
			spawn_rate: 1000,
			time_to_live: 20,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 84,
				y: 19,
				w: 7,
				h: 7,
				pad: 3,
				frames: 4,
				scale: 2,
				duration: 5,
			},
		},
	},
	
	
	{
		id: "energyshot_bloom",
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: -10,

		//When our animation ends we want to disappear and transfer to being a particle_system_holder which will keep the particle system going.
		on_end_anim: "[
			set(hitpoints, 30), 
			set(type, 'particle_system_holder'), 
			fire_event('create'),
		]",

		//we want to spawn a bunch of particles at the start, and then stop, so
		//we schedule an event to stop spawning immediately after we are created.
		on_create: "[
			add_particles('particles'), 
			schedule(1, fire_event('stop_spawning_particles')),
		]",
		
		on_stop_spawning_particles: "set(particle_systems['particles'].spawn_rate, 0)",
		
		animation: {
			id: "sparkle",
			image: "effects/powerup-fx.png",
			x: 122,
			y: 2,
			w: 21,
			h: 23,
			pad: 3,
			frames: 8,
			frames_per_row: 4,
			duration: 2,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			spawn_rate: 10000,
			time_to_live: 20,
			min_x: 10,
			max_x: 20,
			min_y: 10,
			max_y: 20,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 1000,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 84,
				y: 19,
				w: 7,
				h: 7,
				pad: 3,
				frames: 4,
				scale: 2,
				duration: 5,
			},
		},
	},
	
	{
		id: "super_energyshot",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: 500,
		
		properties: {
			attack_damage: "lib.math.round(standard_thrown_damage*(4/3.0))",
			team: "'player'",
			dies_upon_dealing_damage: false,
			damage_cooldown: 20,
			damage_type: "'energy'",
			goes_through_enemy_shots: true,
		},
		
		
		on_create: "[
			set(animation, 'init'),
			sound('energy-shot-uber.wav'),
			sound('energy-uber-fizzle.wav'),
			schedule(80,animation('dissipate')),
			add_particles('particles'),
		]",
	
		on_process: "[
			set(velocity_x,lib.math.round(velocity_x*1.01)),
			set(velocity_y,lib.math.round(velocity_y*1.01)),
			set(lights, [circle_light(me, wave(cycle*100+1d20)/100)]),
		]",

		
		on_end_anim: "if(animation = 'dissipate', die(), animation('normal'))",
		on_collide_level: "",
		
		animation: [
		{
			//body_area: "all",
			id: "init",
			image: "effects/particles2.png",
			x:111, y:319, w:36, h:32,
			attack_area: [0,0,32,32,"solid"],
			pad: 3,
			frames: 8,
			frames_per_row: 2,
			duration: 2,
			feet_x: 18,
			feet_y: 16,
		},
		{
			//body_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			x:154, y:144, w:100, h:32,
			attack_area: [0,0,100,32,"solid"],
			pad: 3,
			frames: 5,
			frames_per_row: 1,
			duration: 2,
			feet_x: 76 ,
			feet_y: 16,
		},
		{
			body_area: "all",
			id: "dissipate",
			image: "effects/particles2.png",
			x:247, y:1, w:36, h:32,
			attack_area: [0,0,36,32,"solid"],
			pad: 3,
			frames: 12,
			frames_per_row: 4,
			duration: 4,
			feet_x: 18 ,
			feet_y: 16,
		},
		],
		particle_system: {
			id: "particles",
			type: "simple",
			min_x: 68,
			max_x: 100,
			min_y: 0,
			max_y: 36,
			spawn_rate: 1000,
			time_to_live: 20,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 84,
				y: 19,
				w: 7,
				h: 7,
				pad: 3,
				frames: 4,
				scale: 2,
				duration: 5,
			},
		},
	},
	
	{
		id: "super_homingshot",
		dies_on_inactive: true,
		
		properties: {
			orb_count: "6",
			current_angle: "int :: cycle*2",
			ang_offset: "def(int n) -> decimal n*(360.0/orb_count)",
			radius: "int :: int(min(cycle/0.5,80))",
			
			_orbs: { type: "[custom_obj]|null", default: null },
		},
		
		on_create: "[set(parent,level.player),
			[ spawn('frogatto_playable.super_homingshot_orb',mid_x,mid_y,facing, [add(me._orbs, [child])]) | v <- range(orb_count)],
			sound('energyshot.ogg'),
			schedule(2000,fire_event(me,'remove')),
		]",
		
		on_process: "[set(relative_x,0),set(relative_y,0),
					 if(me._orbs != null,
						map(me._orbs,
						[set(value.mid_x, me.mid_x + radius*cos(current_angle + ang_offset(index))),
						set(value.mid_y, me.mid_y + radius*sin(current_angle + ang_offset(index)))] ))]",
	
		on_remove: "[ [fire_event( (custom_obj <- v),'die') | v <- me._orbs], die()]",
		//on_remove: "[ map(me._orbs, fire_event(value,'die')), die()]",

		
		on_end_anim: "animation('normal')",
		on_collide_level: "",
		
		animation: {
			id: "normal",
			image: "effects/particles2.png",
			x:111, y:319, w:1, h:1,
			pad: 3,
			frames: 8,
			frames_per_row: 2,
			duration: 2,
			feet_x: 18,
			feet_y: 16,
		},

	},

	{
		id: "super_homingshot_orb",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		properties: {
			goes_through_enemy_shots: true,
			attack_damage: 50,
			damage_type: "'energy'",
			team: "'player'",
			
			_exploded: { type: "bool", default: false },
		},
		
		on_create: "[
			set(time_in_animation, 1d6),
			spawn('frogatto_playable.homingshot_bloom',midpoint_x,midpoint_y,0), 
			add_particles('particles'),
		]",
		
		// When we die we want to keep the particles coming. So, we turn into a particle_system_holder object and set our hitpoints to the number of cycles we want to keep the particles running for. We schedule turning into the particle system holder next frame, because we want to remain as we are this frame so any remaining collisions can be properly resolved.
		
		on_die:"remove_object(me)",

					
	
		on_end_anim: "[animation('normal')]",
		
		animation: {
			body_area: "all",
			attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			x: 1,
			y: 208,
			w: 15,
			h: 15,
			pad: 3,
			frames: 4,
			duration: 1,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			min_y: 9,
			max_y: 13,
			spawn_rate: 300,
			time_to_live: 24,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 1,
				y: 227,
				w: 7,
				h: 7,
				pad: 3,
				frames: 8,
				frames_per_row:4,
				scale: 2,
				duration: 3,
			},
		},
	},
	
	{
		id: "homingshot_bloom",
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: -10,
		
		on_end_anim: "die()",

		animation: {
			id: "sparkle",
			image: "effects/homing-shot-init.png",
			rect: [1,1,31,31],
			frames:9,
			frames_per_row:3,
			duration: 2,
			pad: 3,
		},
	},


	{
		id: "homingshot_impact",
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: -10,

		//when our animation ends we want to disappear and transfer to being a particle_system_holder which will keep the particle system going.
		on_end_anim: "[
			set(hitpoints, 30), 
			set(type, 'particle_system_holder'), 
			fire_event('create'),
		]",

		//we want to spawn a bunch of particles at the start, and then stop, so we schedule an event to stop spawning immediately after we are created.
		on_create: "[
			add_particles('particles'), 
			schedule(1, fire_event('stop_spawning_particles')),
		]",
		
		on_stop_spawning_particles: "set(particle_systems['particles'].spawn_rate, 0)",
		
		animation: {
			id: "sparkle",
			image: "effects/homing-shot-impact.png",
			rect: [1,1,31,41],
			frames:11,
			duration: 3,
			pad: 3,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			min_y: 9,
			max_y: 13,
			spawn_rate: 1000,
			time_to_live: 24,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 1,
				y: 227,
				w: 7,
				h: 7,
				pad: 3,
				frames: 8,
				frames_per_row:4,
				scale: 2,
				duration: 3,
			},
		},
	},
	
	{
		id: "homingshot",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		properties: {
			goes_through_enemy_shots: true,
			attack_damage: 50,
			damage_type: "'energy'",
			team: "'player'",
			speed: 700,
			accel_speed: 0.2,
			decay: 0.99,
			multiplier_x: "if(_target_lock != null, cos(lib.math.angle(me,_target_lock)), 1.0)",
			multiplier_y: "if(_target_lock != null, sin(lib.math.angle(me,_target_lock)), 1.0)",
			my_angle: "if(_target_lock != null, lib.math.angle(me,_target_lock), 0)",
			nearest_enemy: "choose(filter(filter(level.active_chars, value is obj hittable), value.team = 'evil' and (not value.is_a_shot = true)), -lib.math.length(value, self)) or level.player",
			
			_exploded: { type: "bool", default: false },
			_target_lock: { type: "custom_obj|null", default: null },
		},
		
		on_create: "[
			set(time_in_animation, 1d6),
			sound('homing.wav'),
			schedule(250,die()),
			set(_target_lock, nearest_enemy),
			spawn('frogatto_playable.homingshot_bloom',midpoint_x,midpoint_y,0), 
			add_particles('particles'),
		]",
		
		on_process: "[
			if(_target_lock, [
				set(velocity_x, median(-speed, velocity_x*decay + multiplier_x*speed*accel_speed, speed)),
				set(velocity_y,median(-speed,velocity_y*decay+multiplier_y*speed*accel_speed,speed)),
			],[
				set(velocity_x, 600*sign(velocity_x)),
				set(velocity_y, 600*sign(velocity_y)),
				set(_target_lock, nearest_enemy),
			]),
			set(lights, [circle_light(me, wave(cycle*100+1d20)/100)]),
		]",

		// When we die we want to keep the particles coming. So, we turn into a particle_system_holder object and set our hitpoints to the number of cycles we want to keep the particles running for. We schedule turning into the particle system holder next frame, because we want to remain as we are this frame so any remaining collisions can be properly resolved.
		on_die: "[
			set(hitpoints, 30), 
			if(not _exploded, [
				set(_exploded, true), 
				spawn('frogatto_playable.homingshot_impact', midpoint_x, midpoint_y, 0, set(child.rotate,my_angle)),
				sound('homingimpact.wav'), 
				set(hitpoints, 30), 
				set(particle_systems['particles'].spawn_rate, 0), 
				schedule(0, [
					set(type, 'particle_system_holder'), 
					fire_event('create'),
				])
			])
		]",
					
		timer_frequency: 21,
		on_timer: "if((not _target_lock in level.active_chars) or _target_lock = level.player, set(_target_lock, nearest_enemy))",
		
		on_end_anim: "[animation('normal')]",
		
		animation: {
			body_area: "all",
			attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			x: 1,
			y: 208,
			w: 15,
			h: 15,
			pad: 3,
			frames: 4,
			duration: 1,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			min_y: 9,
			max_y: 13,
			spawn_rate: 1000,
			time_to_live: 24,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 1,
				y: 227,
				w: 7,
				h: 7,
				pad: 3,
				frames: 8,
				frames_per_row:4,
				scale: 2,
				duration: 3,
			},
		},
	},
],

}
