{
id: "dangling_rope_controller",
next_animation: "'normal'",
always_active: true, //A hack until we figure out the proper active area.
zorder: "@include data/zorder.cfg:in_front_of_everything",
hidden_in_game: true,
is_strict: true,

editor_info: {
	category: "controllers",
	help: "The rope controller is tied to the controller object, and is drawn between the two lines.",
},

properties: {
	length: {
		type: "int", 
		default: "@eval mid_y+256", 
		editor_info: {type: "y", value: "mid_y+256",},
	},
	
	desired_rope_type: {
		type: "string", 
		value: "'normal'", 
		editor_info: {
			type: "enum", 
			value: "'normal'", 
			enum_values: ["normal", "dark", "chain", /*"track", "tongue",*/ "arrow ribbon"],
		},
	},
	
	segments: {
		type: "[obj rope_angled_controller]",
		default: [],
	},
	
	original_offsets: {
		type: "[Point2d]",
		default: [],
	},
	
	//Strength of sways caused by wind. A list of 1d vectors.
	//The second vector is implicit, because the rope doesn't stretch and change length.
	sway: {
		type:   "{wind: decimal}",
		default: {wind: 0.0    } ,
	},
	
	nudges: {
		type: "[[decimal]]", //List of nudge offsets for each rope segment joint. A list of lists of 1d vectors.
		default: [],
	},
	
	hanging_objects: {
		type: "[obj frogatto_playable | obj movable_enemy]",
		default: [],
	},
	
	tension_at_segment: "def(int index) -> decimal 0
		+ (size(segments)-index+0.5)*0.5 //Unit weight, the weight of the rope and all the rope beneath it.
	",
	
	rope_point_offsets: "[Point2d] <- [[0,0]] + rotated
		where rotated = calculate_rope_segment_heights(0, [0,0], gravity_pull)
		where gravity_pull = [[0,0]]+(
			map(last_pos, 
				[value[0]*(0+diff) + points_above[index][0]*(1-diff), value[1]] 
				where diff = 1.0/(abs(tension_at_segment(index+1))+1) )
			where points_above = [[0,0]]+last_pos )
		where last_pos = map(segments, [
			value.x_2-original_offsets[index+1][0]+wind_sway[index][0], 
			value.y_2-original_offsets[index+1][1]+wind_sway[index][1]])
		where wind_sway = [Point2d] <- ([[sway.wind, 0]])*size(segments)",
		
	calculate_rope_segment_heights: "def(int index, Point2d reference_location, [Point2d] gravity_pull) -> [Point2d] 
			base index = size(gravity_pull)-2:
				[normalize(gravity_pull[index], gravity_pull[index+1], index)]
			recursive: 
				[normalized_point] + calculate_rope_segment_heights(index+1, normalized_point, gravity_pull) 
					where normalized_point = normalize(gravity_pull[index], gravity_pull[index+1], index)",
	normalize: "def(Point2d a, Point2d b, int index) -> Point2d 
		b or lib.math.rotate([0, -32*index], angle(0, -32*index, b[0], b[1])-90, [0,0])", //Commented out via "b or", floating point math is a pain.
},

on_create: "[
	map(segments, remove_object(value)), //Remove previously existing segments because the editor gets a bit confused and doubles them up otherwise.
	set(segments, new_segments),
	map(new_segments, add_object(value)),
	
	set(original_offsets, [Point2d <- me.mid_xy] //Calc the base position for the endpoints of the rope.
		+ map(new_segments, Point2d <- [value.x_2, value.y_2] asserting value is obj rope_angled_controller)),
	
] where new_segments = [object('rope_angled_controller', x, y, {
	x_1: mid_x, 
	y_1: mid_y+seg_y*32, //32 needs to be because it's a multiple of the rope.
	x_2: mid_x, 
	y_2: mid_y+(seg_y+sign(length-mid_y))*32, //Add or subtract one to give us the end-point of our segment.
	animation: desired_rope_type,
}) | seg_y <- range((length-mid_y)/32)]",

on_editor_changed_variable: "[
	set(length, mid_y+round((length-mid_y)/32.0)*32), //Set the red draggy bar to the closest whole rope segment to the mouse. This behaviour feels nice to use.
	fire_event('create'),                                   //(However, due to rounding issues, the length of the rope changes if we drag the object in 'percise mode'. We should really fix the offset calculation to take that into account.)
]",

on_process: "[
	fire_event('update_rope_forces'),
	fire_event('update_rope_position'),
]",

on_update_rope_forces: "[
	set(sway.wind, (sin(cycle*3)+0.5)*1.25),
]",

on_update_rope_position: "map(segments, value.set_ends(
	base_[index+0][0]+offset[index+0][0], base_[index+0][1]+offset[index+0][1], 
	base_[index+1][0]+offset[index+1][0], base_[index+1][1]+offset[index+1][1]
)) where 
	base_ = original_offsets,
    offset = rope_point_offsets",
			
animation: {
	id: "normal",
	image: "effects/particles.png",
	x: 179,
	y: 104,
	w: 28,
	h: 28,
},
}