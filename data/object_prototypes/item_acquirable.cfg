{
id: "item_acquirable",
is_strict: true,
prototype: ["standard_values"],
zorder: "@include data/zorder.cfg:player",
respawns: false,
collide_dimensions: ["~item"],
editor_info: {
	category: "props",
},

properties: {
	been_acquired: { type: "bool", default: false },

#-------------------------- 'attraction' handlers --------------------------#
	attractable: "bool :: false",  //categorically speaking, can this get pulled in by the "magnetic" attractor powerup?
	_should_attract: "bool :: (attractable and _is_inside_attraction_range and if(level.player is obj frogatto_playable, level.player.has_item('acquirable_attractor'), false))",
	_has_started_attracting: "bool :: (not _started_attracting_at_cycle = null)",
	_started_attracting_at_cycle: { type: "int|null", default: null },
	_is_inside_attraction_range: "bool :: (lib.math.length(me,level.player) < 200)",
	_angle_to_player: "decimal :: lib.math.angle(me, level.player)",
	_attraction_speed: "decimal :: 50.0",
	process_attract: "commands :: if(_has_started_attracting and (not been_acquired),
			[	
				add(velocity_x, x_diff) where x_diff = int(_attraction_speed * cos(_angle_to_player) * 1.0),
				add(velocity_y, y_diff) where y_diff = int(_attraction_speed * sin(_angle_to_player) * 1.0),
				
				add(mid_x, x_diff) where x_diff = int(_attraction_speed/10 * cos(_angle_to_player) * 1.0),
				add(mid_y, y_diff) where y_diff = int(_attraction_speed/10 * sin(_angle_to_player) * 1.0),
				
				if(level.cycle - _started_attracting_at_cycle > 200 asserting _started_attracting_at_cycle is int, fire_event('acquired')),
			])",
			
#-------------------------- special interlude sequence FX handlers --------------------------#
	should_lock_player_and_do_fancy_acquisition_interlude: "bool :: false", //only BIG treasures, like heart pieces and such, merit this

	play_acquisition_music: "commands :: if(acquisition_music_filename != '', [	
		map(range(21), schedule(value, set(level.music_volume,1-(1.0*value)/20))),
		map(range(21), schedule(180+value, set(level.music_volume, (1.0*value)/20))),
		sound(acquisition_music_filename),
	])",
	acquisition_music_filename: "string :: 'SpecialItem2.ogg'",

	do_player_item_get_anim: "[set(level.player.invincible, -1), set(level.zoom, 2), set(level.player.control_lock,  []), set(level.player.velocity_x,0), set(level.player.velocity_y,max(0,level.player.velocity_y)), schedule(50,set(level.player.animation, 'item_get_begin'))]",
	
	cleanup_player_item_get_anim: "[set(level.player.animation, 'item_get_end'),
			schedule(40, [set(level.player.control_lock, null),set(level.zoom, 1), set(level.player.invincible, 0)])]",

	do_item_acquisition_interlude_sequence: "[
			#-- initial stuff --#
		set(collide_dimensions_in, []),
		play_acquisition_music,
		do_player_item_get_anim,
		set(alpha,0),
		
			#-- mid timeline stuff --#
		schedule(1, bind_command( def() do_basic_cosmetic_acquisition_fx)),
		schedule(40, bind_command( def() [set(alpha,255),set(mid_x, level.player.mid_x-20*level.player.facing), set(mid_y, level.player.mid_y-40)]) ),
		schedule(40, set(velocity_y,-30)),
	
			#-- cleanup/closing scope --#
		schedule(120, cleanup_player_item_get_anim),
	]",

#-------------------------- cosmetic acquisition FX handlers --------------------------#
	do_basic_cosmetic_acquisition_fx: "[do_screen_flash, do_size_dilation_sequence, do_particle_fx, do_sfx]",

	do_screen_flash: "commands :: null",  
	do_size_dilation_sequence: "commands :: schedule(20, [ //usually this is consistent, but in rare cases it might need to be custom
		sinusoidal_scale_transition(150,0,90, 1, 1),
		schedule(150, sinusoidal_scale_transition(30,90,90, 0, 2)),
	])",
	do_particle_fx: "commands :: null",
	do_sfx: "commands :: null",
	removal_time: "int :: 201", //only really customized for stuff that has a very fast size_dilation, and isn't doing the interlude thing.
	
#-------------------------- acquisition handlers --------------------------#
	do_acquisition: "commands :: [
		set(been_acquired, true),
		if(should_lock_player_and_do_fancy_acquisition_interlude, do_item_acquisition_interlude_sequence),
		if(not should_lock_player_and_do_fancy_acquisition_interlude, do_basic_cosmetic_acquisition_fx),
		[set(velocity_x, 0),set(velocity_y, 0)],
		schedule(1, bind_command( def() fire_event('acquired') )),
		schedule(removal_time, die())
	]",
},

on_process: "[if(_should_attract, set(_started_attracting_at_cycle,level.cycle)), process_attract]",

on_end_normal_anim: "animation('normal')",

on_collide_object_item: "if(arg.collide_with is obj hittable,[if(collide_with.is_player_body_part and (not been_acquired),do_acquisition)] where collide_with = obj hittable <- arg.collide_with)",


// expected behaviors:
// To be acquirable 'by touch', you need to have an "item" area in an object's animation, and you need to be in the 'item' collide dimension.
// on_acquired: "/* virtual; each object will need almost completely custom behavior for what it actually *does* when it's acquired.  This should only cover the actual gameplay effects, and/or possibly a speech dialog */",

}
